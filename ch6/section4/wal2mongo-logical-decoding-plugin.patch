diff --git a/contrib/wal2mongo/.gitignore b/contrib/wal2mongo/.gitignore
new file mode 100644
index 0000000000..27e7c812fa
--- /dev/null
+++ b/contrib/wal2mongo/.gitignore
@@ -0,0 +1,56 @@
+# regressio test outputs
+/regression.diffs
+/regression.out
+/results/
+
+# Prerequisites
+*.d
+
+# Object files
+*.o
+*.ko
+*.obj
+*.elf
+
+# Linker output
+*.ilk
+*.map
+*.exp
+
+# Precompiled Headers
+*.gch
+*.pch
+
+# Libraries
+*.lib
+*.a
+*.la
+*.lo
+
+# Shared objects (inc. Windows DLLs)
+*.dll
+*.so
+*.so.*
+*.dylib
+
+# Executables
+*.exe
+*.app
+*.i*86
+*.x86_64
+*.hex
+
+# Debug files
+*.dSYM/
+*.su
+*.idb
+*.pdb
+
+# Kernel Module Compile Results
+*.mod*
+*.cmd
+.tmp_versions/
+modules.order
+Module.symvers
+Mkfile.old
+dkms.conf
diff --git a/contrib/wal2mongo/.travis.yml b/contrib/wal2mongo/.travis.yml
new file mode 100644
index 0000000000..d49cbadf40
--- /dev/null
+++ b/contrib/wal2mongo/.travis.yml
@@ -0,0 +1,53 @@
+# run the testsuite on travis-ci.org
+---
+# run once for each of these
+env:
+  global:
+  - enable_coverage=yes
+  - PGVERSION=12
+
+language: C
+dist: bionic
+sudo: required
+
+before_install:
+  - sudo apt-get update -qq
+  - pip install --user cpp-coveralls
+
+install:
+  # remove all existing postgresql
+  - sudo rm -rf /etc/postgresql /var/lib/postgresql
+  - wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -
+  - echo "deb http://apt.postgresql.org/pub/repos/apt/ `lsb_release -cs`-pgdg main" |sudo tee  /etc/apt/sources.list.d/pgdg.list
+  - sudo apt update
+  - sudo pip install cpp-coveralls
+  - sudo apt -y install postgresql-12 postgresql-client-12 postgresql-server-dev-12
+  - sudo apt-get install -y postgresql-common
+  - sudo apt-get install -y bison flex libicu-dev libssl-dev git
+  - sudo -u postgres createuser --superuser $USER
+  - sudo sed -i 's/#wal_level = replica/wal_level = logical/g' /etc/postgresql/12/main/postgresql.conf
+  - sudo service postgresql@12-main restart
+  - git clone https://github.com/idrawone/wal2mongo.git
+
+script:
+  - cd wal2mongo
+  - export PATH=/usr/lib/postgresql/12/bin:$PATH
+  - USE_PGXS=1 make
+  - sudo USE_PGXS=1 make install
+  - USE_PGXS=1 make installcheck-force
+  - if test -s regression.diffs; then cat regression.diffs; cat results/string.out; cat expected/string.out; fi
+
+after_success:
+  - coveralls --gcov-options '\-lp'
+
+deploy:
+  provider: releases
+  api_key: 
+    secure: "Cikugg6yUXIyHoRYN+oLzSbRNyJ5N7JR1IYkJjgBS2ZogqxMHhZszdYCTI7FyfdzzUA3qJLiARuYpOjtk/OxzZ1b4c1+kk4miwjeNEfSZFhEUfhPq9sAD+gBq/akCQhFUWf5OQiA/DQBivL0sVIxmHc8oE9YpMMKPze2WQZvQO/g6fctzkP2eKVA2/Mq+JO4uU/VCm0PTNKNSEnO54j+riKf3qsElOzJ9GX5kWl3gOV4UQoAn+GzvH7SwzB5iex3FXEtSPuW5d80LmtOb5vJB3YJH9Yk49DMhER5W6BBgcYC/BNgfpHjSeR5fCDV4pfmfkSLD6mV2Rsy2ke8NQDFeVXbr8SZtMsEAfdTb7M8ima+CtjoawBe/SwNxEA5QuhpuQGeAvfSJzAMU+dGvvajtC1dU6GehWvBcdbxiU7VcWjItfCrV9BVh3zCdo+1keAkpO078eeb5C8qiqK4yiJ6GN1S7jIx9Y6I9VeNLjOqIRuxjt4dqmT7LBNsksA1SGddvt5jzQXjGzV34P26b31aba0Xf0eCPqpMEcv28O7vB2wBB05TC+yjgUWBUrWvVz3sDcTrhBFxlZwQc2li37brIx5bHB4lG2SG8KoUatujYUuNP2mifJaW5lXv9ibIefPac+SNjG4A+lW7x35/vvVcwcOoFK9fgZav+Q8JbzbrPH8="
+  file_glob: true
+  file: "*.so"
+  skip_cleanup: true
+  on:
+    repo: HighgoSoftware/wal2mongo
+    branch: release
+    tags: true
diff --git a/contrib/wal2mongo/LICENSE b/contrib/wal2mongo/LICENSE
new file mode 100644
index 0000000000..261eeb9e9f
--- /dev/null
+++ b/contrib/wal2mongo/LICENSE
@@ -0,0 +1,201 @@
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
diff --git a/contrib/wal2mongo/Makefile b/contrib/wal2mongo/Makefile
new file mode 100644
index 0000000000..35719d5463
--- /dev/null
+++ b/contrib/wal2mongo/Makefile
@@ -0,0 +1,34 @@
+# contrib/wal2mongo/Makefile
+
+MODULES = wal2mongo
+PGFILEDESC = "wal2mongo - a logical decoding output plugin for MongoDB"
+
+REGRESS = binary actions transaction boolean numeric binData timestamptz \
+		  array json string xml identity pkey specval
+
+#ISOLATION = mxact delayed_startup ondisk_startup concurrent_ddl_dml \
+	oldest_xmin snapshot_transfer
+
+REGRESS_OPTS = --temp-config $(top_srcdir)/contrib/wal2mongo/logical.conf
+#ISOLATION_OPTS = --temp-config $(top_srcdir)/contrib/wal2mongo/logical.conf
+
+# Disabled because these tests require "wal_level=logical", which
+# typical installcheck users do not have (e.g. buildfarm clients).
+NO_INSTALLCHECK = 0
+
+ifdef USE_PGXS
+PG_CONFIG = pg_config
+PGXS := $(shell $(PG_CONFIG) --pgxs)
+include $(PGXS)
+else
+subdir = contrib/wal2mongo
+top_builddir = ../..
+include $(top_builddir)/src/Makefile.global
+include $(top_srcdir)/contrib/contrib-global.mk
+endif
+
+# But it can nonetheless be very helpful to run tests on preexisting
+# installation, allow to do so, but only if requested explicitly.
+installcheck-force:
+	$(pg_regress_installcheck) $(REGRESS)
+	#$(pg_isolation_regress_installcheck) $(ISOLATION)
diff --git a/contrib/wal2mongo/NOTICE b/contrib/wal2mongo/NOTICE
new file mode 100644
index 0000000000..f7edb8ca02
--- /dev/null
+++ b/contrib/wal2mongo/NOTICE
@@ -0,0 +1,11 @@
+Copyright (c) 2020 HighGo Software, Inc. (Canada). All Rights Reserved.
+
+This project contains software that is Copyright (c) 2020 HighGo Software, Inc.
+
+This project is licensed to you under the Apache License, Version 2.0 (the "License").
+
+You may not use this project except in compliance with the License.
+
+This project may include a number of subcomponents with separate copyright notices
+and license terms. Your use of these subcomponents is subject to the terms and 
+conditions of the subcomponent's license, as noted in the LICENSE file.
diff --git a/contrib/wal2mongo/README.cn.md b/contrib/wal2mongo/README.cn.md
new file mode 100644
index 0000000000..e02daca924
--- /dev/null
+++ b/contrib/wal2mongo/README.cn.md
@@ -0,0 +1,252 @@
+![License](https://img.shields.io/github/license/HighgoSoftware/wal2mongo)
+![Build](https://travis-ci.com/HighgoSoftware/wal2mongo.svg?branch=release)
+[![Release](https://img.shields.io/github/v/tag/HighgoSoftware/wal2mongo?label=Release)](https://github.com/HighgoSoftware/wal2mongo/releases)
+
+### 介绍 
+`wal2mongo` 是一个PostgreSQL逻辑解码输出插件，用来输出mongo能够接受JSON格式，使PostgreSQL到MongoDB的逻辑复制更加容易。
+
+### 使用条件
+要使用wal2mongo逻辑解码输出插件，需要安装以下PostgreSQL服务器之一，
+* [PostgreSQL 12.x](https://www.postgresql.org/download)
+* [HighGo PostgreSQL Server 1.x](https://www.highgo.ca/products/highgo-postgresql-server)
+
+### 编译，测试和安装
+`wal2mongo` 支持两种编译方式：一种是针对希望在PostgreSQL源代码树结构下管理 wal2mongo 代码的开发人员。 另一个是针对希望将wal2mongo集成到已编译好的PostgreSQL的开发人员或DBA。
+
+#### 类似Linux的环境中
+* 在PostgreSQL源代码树下构建
+```
+cd /path/to/postgres/contrib/
+git clone https://github.com/HighgoSoftware/wal2mongo.git
+cd wal2mongo
+make
+make install
+make check
+```
+
+* 针对PostgreSQL二进制文件编译
+```
+mkdir sandbox
+cd sandbox
+git clone https://github.com/HighgoSoftware/wal2mongo.git
+cd wal2mongo
+```
+
+将 “PATH” 指向现有的PostgreSQL二进制目录。 使用`PGHOST`和`PGPORT`指定一个PostgreSQL服务器和端口来运行installcheck-force测试。
+```
+$ export PATH=/path/to/postgres/bin:$PATH
+USE_PGXS=1 make
+USE_PGXS=1 make install
+USE_PGXS=1 make installcheck-force
+```
+
+#### 在Windows 7、10和2019服务器上
+* 在PostgreSQL源代码树下编译
+1. 按照 [此处](https://www.postgresql.org/docs/12/install-windows-full.html) 的说明使用Microsoft Windows SDK设置编译环境. [Visual Studio 2019社区版](https://visualstudio.microsoft.com/downloads/) 足以编译Postgres 12.x和wal2mongo逻辑解码输出插件。 成功安装VS 2019之后，请下载 [`ActivePerl 5.28`](https://www.activestate.com/products/perl/downloads/), [`ActiveTcl 8.6`](https://www.activestate.com/products/tcl/downloads/) 和 [`GnuWin32 0.6.3`](https://sourceforge.net/projects/getgnuwin32/files/getgnuwin32/0.6.30/GetGnuWin32-0.6.3.exe/download) 然后使用默认设置安装即可。
+
+2. 在环境变量管理面板中检查系统变量的 “ActivePerl”，“ActiveTcl” 和 “GnuWin32” 的二进制路径，如果不存在，请添加它们。
+
+3. 编译并安装
+
+```
+cd \path\to\postgres\contrib\
+git clone https://github.com/HighgoSoftware/wal2mongo.git
+cd \path\to\postgres\src\tools\msvc\
+build
+install \path\to\install\foler\
+```
+4. 运行回归测试（注意，vcregress尚不支持单个扩展的回归测试）
+```
+vcregress contribcheck
+```
+* 针对PostgreSQL二进制文件编译
+
+可以按照以下步骤使用Visual Studio 2019编译`wal2mongo`
+1. 使用空项目 （empty project）模板创建一个新项目，例如，将项目名称设置为 `wal2mongo`
+2. 右键单击 `wal2mongo` 项目->添加->新项目...，选择 `C ++ File`，但将其命名为`wal2mongo.c`。
+3. 将来自github的所有c源代码粘贴到本地“ wal2mongo.c” 文件中。
+4. 将 “PGDLLEXPORT” 添加到函数 “_PG_init” 和 “_PG_output_plugin_init”中，如下所示，
+```
+extern PGDLLEXPORT void _PG_init(void);
+extern PGDLLEXPORT void _PG_output_plugin_init(OutputPluginCallbacks* cb);
+```
+5. 右键点击`wal2mongo`项目->属性，然后更改以下设置，
+常规->配置类型“动态库（.dll）”
+
+设置C / C++ ->代码生成->启用C++ exceptions 的设置改为`否`
+
+设置C / C ++->高级->编译为`编译为C代码`
+
+将链接器->清单文件->生成清单设置为“否”
+
+将`postgres.lib`添加到链接器->输入->其他依赖项
+
+根据PostgreSQL二进制文件的安装位置，按以下顺序将以下路径添加到 C / C++ ->常规->其他include目录
+
+```
+C:\Users\Administrator\Downloads\pg12.2\include\server\port\win32_msvc
+C:\Users\Administrator\Downloads\pg12.2\include\server\port\win32
+C:\Users\Administrator\Downloads\pg12.2\include\server
+C:\Users\Administrator\Downloads\pg12.2\include
+```
+同样，根据PostgreSQL二进制文件的安装位置，在Linker-> General-> Additional Library Directories 中添加如下所示的库路径
+```
+C:\Users\Administrator\Downloads\pg12.2\lib
+```
+6. 右键点击`wal2mongo`，然后点击`build`。 如果一切正常，则应该显示以下消息。
+```
+1>wal2mongo.vcxproj -> C:\Users\Administrator\source\repos\wal2mongo\Debug\wal2mongo.dll
+1>Done building project "wal2mongo.vcxproj".
+========== Rebuild All: 1 succeeded, 0 failed, 0 skipped ==========
+```
+7. 手动将 “wal2mongo.dll” 复制到安装了PostgreaSQL的 “lib”中，然后按照示例部分进行测试。
+
+
+### 设置和配置
+编辑PostgreSQl配置文件 “postgresql.conf”，并确保将 “wal_level” 设置为 “logical”，并且将 “max_replication_slots” 设置为至少1（默认设置为10）。
+重新启动postgres服务。
+
+### 选件
+有待确定...
+
+### 样例
+下面是两种使用wal2mongo将数据从PostgreSQL复制到MongoDB的简单方法：一种使用psql console；另一个使用pg_recvlogical工具。
+
+#### 使用psql console
+* 创建一个逻辑插槽
+例如，使用输出插件 “wal2mongo” 创建一个名为 “w2m_slot”的逻辑插槽。
+```
+postgres=# SELECT * FROM pg_create_logical_replication_slot('w2m_slot', 'wal2mongo');
+ slot_name |    lsn     
+-----------+------------
+ w2m_slot  | 1/3CB04148
+(1 row)
+```
+
+* 检查刚创建的插槽
+```
+postgres=# SELECT slot_name, plugin, slot_type, database, active, restart_lsn, confirmed_flush_lsn FROM pg_replication_slots;
+ slot_name |  plugin   | slot_type | database | active | restart_lsn | confirmed_flush_lsn 
+-----------+-----------+-----------+----------+--------+-------------+---------------------
+ w2m_slot  | wal2mongo | logical   | postgres | f      | 1/3CB04110  | 1/3CB04148
+(1 row)
+```
+
+* 创建一个表并插入数据
+```
+postgres=# CREATE TABLE books (
+  id  	 SERIAL PRIMARY KEY,
+  title	 VARCHAR(100) NOT NULL,
+  author VARCHAR(100) NULL
+);
+
+postgres=# insert into books
+(id, title, author) 
+values
+(123, 'HG-PGSQL1.1', 'Highgo');
+```
+
+* 查看有无任何改动
+```
+postgres=# SELECT * FROM pg_logical_slot_peek_changes('w2m_slot', NULL, NULL);
+    lsn     | xid  |                                  data                                  
+------------+------+------------------------------------------------------------------------
+ 1/3CB247F8 | 1793 | db.books.insertOne( { id:123, title:"HG-PGSQL1.1", author:"Highgo" } )
+(1 row)
+```
+
+* 取得改动
+```
+postgres=# SELECT * FROM pg_logical_slot_get_changes('w2m_slot', NULL, NULL);
+    lsn     | xid  |                                  data                                  
+------------+------+------------------------------------------------------------------------
+ 1/3CB247F8 | 1793 | db.books.insertOne( { id:123, title:"HG-PGSQL1.1", author:"Highgo" } )
+(1 row)
+```
+
+* 使用 mongo 客户端中复制数据（选项1）
+
+登录 mongoDB，然后复制数据部分中的所有字符串，然后粘贴到 mongo 客户端上
+```
+> db.books.insertOne( { id:123, title:"HG-PGSQL1.1", author:"Highgo" } )
+{
+	"acknowledged" : true,
+	"insertedId" : ObjectId("5e5ea92be9684c562aae5b7a")
+}
+```
+
+* 使用.js文件复制数据（选项2）
+
+复制输出的所有字符串，然后将其粘贴到文件中，例如 test.js，然后使用mongo客户端导入文件
+```
+$ mongo < test.js 
+MongoDB shell version v4.0.16
+connecting to: mongodb://127.0.0.1:27017/?gssapiServiceName=mongodb
+Implicit session: session { "id" : UUID("86ddf177-9704-43f9-9f66-31ac1f9f89e0") }
+MongoDB server version: 4.0.16
+{
+	"acknowledged" : true,
+	"insertedId" : ObjectId("5e5ea8f3bb2265ca8fa4b7ae")
+}
+bye
+```
+
+* 检查复制的数据
+```
+> db.books.find();
+{ "_id" : ObjectId("5e5ea8f3bb2265ca8fa4b7ae"), "id" : 123, "title" : "HG-PGSQL1.1", "author" : "Highgo" }
+> 
+```
+
+* 删除逻辑插槽如果不再使用的话
+```
+postgres=# SELECT pg_drop_replication_slot('w2m_slot');
+ pg_drop_replication_slot 
+--------------------------
+ 
+(1 row)
+```
+
+#### 使用 pg_recvlogical
+* 创建一个逻辑插槽
+```
+$ pg_recvlogical -d postgres --slot w2m_slot2 --create-slot --plugin=wal2mongo
+```
+
+* 在终端1上启动pg_recvlogical
+```
+$ pg_recvlogical -d postgres --slot w2m_slot2 --start -f -
+```
+或者让 pg_recvlogical 记录所有数据改动到一个文件，例如
+```
+$ pg_recvlogical -d postgres --slot w2m_slot2 --start -f test2.js
+```
+
+* 创建一个表并从终端2插入数据
+```
+postgres=# CREATE TABLE books (
+  id  	 SERIAL PRIMARY KEY,
+  title	 VARCHAR(100) NOT NULL,
+  author VARCHAR(100) NULL
+);
+
+postgres=# insert into books
+(id, title, author) 
+values
+(124, 'HG-PGSQL1.2', 'Highgo');
+```
+
+* 切换回终端1来检查更改
+
+如下所示的一条记录应该显示在终端1或文件 test2.js 中，
+```
+db.books.insertOne( { id:124, title:"HG-PGSQL1.2", author:"Highgo" } )
+```
+
+* 将数据复制到mongoDB
+
+* 删除逻辑插槽如果不再使用的话
+```
+$ pg_recvlogical -d postgres --slot w2m_slot2 --drop-slot 
+```
+
diff --git a/contrib/wal2mongo/README.md b/contrib/wal2mongo/README.md
new file mode 100644
index 0000000000..03581f81e7
--- /dev/null
+++ b/contrib/wal2mongo/README.md
@@ -0,0 +1,251 @@
+![License](https://img.shields.io/github/license/HighgoSoftware/wal2mongo)
+![Build](https://travis-ci.com/HighgoSoftware/wal2mongo.svg?branch=release)
+[![Release](https://img.shields.io/github/v/tag/HighgoSoftware/wal2mongo?label=Release)](https://github.com/HighgoSoftware/wal2mongo/releases)
+
+### Introduction 
+`wal2mongo` is a PostgreSQL logical decoding output plugin designed to make the logical replication easier from `PostgreSQL` to `MongoDB` by formating the output to a JSON-like format accepted by `mongo`.
+
+### Prerequisites
+To use wal2mongo logical decoding output plugin, either one of below PostgreSQL servers need to be installed,
+* [PostgreSQL 12.x](https://www.postgresql.org/download)
+* [HighGo PostgreSQL Server 1.x](https://www.highgo.ca/products/highgo-postgresql-server)
+
+### Build, Test and Install
+`wal2mongo` is designed to support two typical ways for building PostgreSQL extension: one is for developers who want to manage `wal2mongo` source code under PostgreSQL source code tree structure; the other one is for developers or DBA who want to integrate `wal2mongo` to existing PostgreSQL binaries.
+
+#### On a Linux-like environment
+* Build under PostgreSQL Source Code Tree
+```
+cd /path/to/postgres/contrib/
+git clone https://github.com/HighgoSoftware/wal2mongo.git
+cd wal2mongo
+make
+make install
+make check
+```
+
+* Build against PostgreSQL binaries
+```
+mkdir sandbox
+cd sandbox
+git clone https://github.com/HighgoSoftware/wal2mongo.git
+cd wal2mongo
+```
+
+Set the `PATH` to point to existing PostgreSQL binary directory. Use `PGHOST` and `PGPORT` to specify a PostgreSQL server and port to run the installcheck-force test against if different from default ones.
+```
+$ export PATH=/path/to/postgres/bin:$PATH
+USE_PGXS=1 make
+USE_PGXS=1 make install
+USE_PGXS=1 make installcheck-force
+```
+
+#### On Windows7, 10 and 2019 Server
+* Build under PostgreSQL Source Code Tree
+1. Following the instruction [here](https://www.postgresql.org/docs/12/install-windows-full.html) to setup the build environment using Microsoft Windows SDK. The [Visual Studio 2019 Community](https://visualstudio.microsoft.com/downloads/) is enough for building Postgres 12.x and wal2mongo logical decoding output plugin. After VS 2019 has been installed successfully, download [`ActivePerl 5.28`](https://www.activestate.com/products/perl/downloads/), [`ActiveTcl 8.6`](https://www.activestate.com/products/tcl/downloads/) and [`GnuWin32 0.6.3`](https://sourceforge.net/projects/getgnuwin32/files/getgnuwin32/0.6.30/GetGnuWin32-0.6.3.exe/download) and install them with the default setting would be enough.
+
+2. Check the binaries path for `ActivePerl`, `ActiveTcl` and `GnuWin32` for System variables in Environment variables management panel, if not exist then add them in.
+
+3. Build and install
+
+```
+cd \path\to\postgres\contrib\
+git clone https://github.com/HighgoSoftware/wal2mongo.git
+cd \path\to\postgres\src\tools\msvc\
+build
+install \path\to\install\foler\
+```
+4. Run regress test (notes, regress test a single extension is not supported by vcregress yet)
+```
+vcregress contribcheck
+```
+* Build against PostgreSQL binaries
+
+`wal2mongo` can be built in a separate project folder using Visual Studio 2019 by following the steps below:
+1. Create a `new projec`t using `Empty Project` template, and set `Project name` to `wal2mong`, for example.
+2. Right click `wal2mongo` project -> Add -> New items ..., select `C++ File` but name it as `wal2mongo.c`
+3. Paste all the c source code from github to local `wal2mongo.c` file.
+4. Add `PGDLLEXPORT` to function `_PG_init` and `_PG_output_plugin_init`, like below,
+```
+extern PGDLLEXPORT void _PG_init(void);
+extern PGDLLEXPORT void _PG_output_plugin_init(OutputPluginCallbacks* cb);
+```
+5. Right click `wal2mongo` project -> Properties, then change below settings,
+General -> Configuration Type `Dynamic Library (.dll)`
+
+Set C/C++ -> Code Generation -> Enable C++ Exceptions to `NO`
+
+Set C/C++ -> Advanced -> Compile As to `Compile As C Code`
+
+Set Linker -> Manifest File -> Generate Manifest to `No`
+
+Add `postgres.lib` to Linker -> Input -> Additional Dependencies 
+
+Depends on where PostgreSQL binaries are installed, add below pathes in below order to C/C++ -> General -> Additional Include Directories
+```
+C:\Users\Administrator\Downloads\pg12.2\include\server\port\win32_msvc
+C:\Users\Administrator\Downloads\pg12.2\include\server\port\win32
+C:\Users\Administrator\Downloads\pg12.2\include\server
+C:\Users\Administrator\Downloads\pg12.2\include
+```
+Again, depends on where PostgreSQL binaries are installed, add a path like below to Linker -> General -> Additional Library Directories
+```
+C:\Users\Administrator\Downloads\pg12.2\lib
+```
+6. Right click `wal2mongo1, then click `build`. If everything goes fine, then below message should show up.
+```
+1>wal2mongo.vcxproj -> C:\Users\Administrator\source\repos\wal2mongo\Debug\wal2mongo.dll
+1>Done building project "wal2mongo.vcxproj".
+========== Rebuild All: 1 succeeded, 0 failed, 0 skipped ==========
+```
+7. Manually copy `wal2mongo.dll` to the `lib` where PostgreaSQL is installed, then run test following `Examples` section.
+
+
+### Setup and configuration
+Edit PostgreSQl configuration file `postgresql.conf` and make sure `wal_level` is set to `logical`, and `max_replication_slots` is set at least 1 (default settings is 10).
+Restart postgres services.
+
+### Options
+TBD...
+
+### Examples
+Below are two simple ways to replicate data from PostgreSQL to MongoDB using `wal2mongo`: one use psql console; the other one use pg_recvlogical tools.
+
+#### using psql
+* Create a slot 
+For example, create a slot nameed 'w2m_slot' using the output plugin `wal2mongo`.
+```
+postgres=# SELECT * FROM pg_create_logical_replication_slot('w2m_slot', 'wal2mongo');
+ slot_name |    lsn     
+-----------+------------
+ w2m_slot  | 1/3CB04148
+(1 row)
+```
+
+* Check the slot just created
+```
+postgres=# SELECT slot_name, plugin, slot_type, database, active, restart_lsn, confirmed_flush_lsn FROM pg_replication_slots;
+ slot_name |  plugin   | slot_type | database | active | restart_lsn | confirmed_flush_lsn 
+-----------+-----------+-----------+----------+--------+-------------+---------------------
+ w2m_slot  | wal2mongo | logical   | postgres | f      | 1/3CB04110  | 1/3CB04148
+(1 row)
+```
+
+* Create a table and insert data
+```
+postgres=# CREATE TABLE books (
+  id  	 SERIAL PRIMARY KEY,
+  title	 VARCHAR(100) NOT NULL,
+  author VARCHAR(100) NULL
+);
+
+postgres=# insert into books
+(id, title, author) 
+values
+(123, 'HG-PGSQL1.1', 'Highgo');
+```
+
+* Peek if any changes
+```
+postgres=# SELECT * FROM pg_logical_slot_peek_changes('w2m_slot', NULL, NULL);
+    lsn     | xid  |                                  data                                  
+------------+------+------------------------------------------------------------------------
+ 1/3CB247F8 | 1793 | db.books.insertOne( { id:123, title:"HG-PGSQL1.1", author:"Highgo" } )
+(1 row)
+```
+
+* Retrieve the changes
+```
+postgres=# SELECT * FROM pg_logical_slot_get_changes('w2m_slot', NULL, NULL);
+    lsn     | xid  |                                  data                                  
+------------+------+------------------------------------------------------------------------
+ 1/3CB247F8 | 1793 | db.books.insertOne( { id:123, title:"HG-PGSQL1.1", author:"Highgo" } )
+(1 row)
+```
+
+* Replicate data within mongo console (option 1)
+
+log into mongoDB, and copy all the strings from data section, and paste to mongo console
+```
+> db.books.insertOne( { id:123, title:"HG-PGSQL1.1", author:"Highgo" } )
+{
+	"acknowledged" : true,
+	"insertedId" : ObjectId("5e5ea92be9684c562aae5b7a")
+}
+```
+
+* Replicate data using .js file (option 2)
+
+Copy all the strings from data section, and paste it to a file, e.g. test.js, then import the file using mongo
+```
+$ mongo < test.js 
+MongoDB shell version v4.0.16
+connecting to: mongodb://127.0.0.1:27017/?gssapiServiceName=mongodb
+Implicit session: session { "id" : UUID("86ddf177-9704-43f9-9f66-31ac1f9f89e0") }
+MongoDB server version: 4.0.16
+{
+	"acknowledged" : true,
+	"insertedId" : ObjectId("5e5ea8f3bb2265ca8fa4b7ae")
+}
+bye
+```
+
+* check the data replicated
+```
+> db.books.find();
+{ "_id" : ObjectId("5e5ea8f3bb2265ca8fa4b7ae"), "id" : 123, "title" : "HG-PGSQL1.1", "author" : "Highgo" }
+> 
+```
+
+* Drop a slot if not used any more
+```
+postgres=# SELECT pg_drop_replication_slot('w2m_slot');
+ pg_drop_replication_slot 
+--------------------------
+ 
+(1 row)
+```
+
+#### using pg_recvlogical
+* create a slot
+```
+$ pg_recvlogical -d postgres --slot w2m_slot2 --create-slot --plugin=wal2mongo
+```
+
+* start logical decoding stream on terminal 1
+```
+$ pg_recvlogical -d postgres --slot w2m_slot2 --start -f -
+```
+Or let pg_recvlogical record all the changes to a file, e.g. 
+```
+$ pg_recvlogical -d postgres --slot w2m_slot2 --start -f test2.js
+```
+
+* Create a table and insert data from terminal 2
+```
+postgres=# CREATE TABLE books (
+  id  	 SERIAL PRIMARY KEY,
+  title	 VARCHAR(100) NOT NULL,
+  author VARCHAR(100) NULL
+);
+
+postgres=# insert into books
+(id, title, author) 
+values
+(124, 'HG-PGSQL1.2', 'Highgo');
+```
+
+* Check the changes by switching back to terminal 1
+
+One record like below should be showing up either in console or inside file test2.js,
+```
+db.books.insertOne( { id:124, title:"HG-PGSQL1.2", author:"Highgo" } )
+```
+
+* replcate data to mongoDB same as above
+
+* Drop a slot if not used any more
+```
+$ pg_recvlogical -d postgres --slot w2m_slot2 --drop-slot 
+```
+
diff --git a/contrib/wal2mongo/expected/actions.out b/contrib/wal2mongo/expected/actions.out
new file mode 100644
index 0000000000..952805c72c
--- /dev/null
+++ b/contrib/wal2mongo/expected/actions.out
@@ -0,0 +1,158 @@
+\set VERBOSITY terse
+-- predictability
+SET synchronous_commit = on;
+SELECT 'init' FROM pg_create_logical_replication_slot('regression_slot', 'wal2mongo');
+ ?column? 
+----------
+ init
+(1 row)
+
+-- actions
+CREATE TABLE testing (a integer primary key);
+INSERT INTO testing (a) VALUES(200);
+UPDATE testing SET a = 500 WHERE a = 200;
+DELETE FROM testing WHERE a = 500;
+TRUNCATE TABLE testing;
+-- peek changes according to action configuration
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'actions', 'insert', 'regress', 'true');
+                                         data                                         
+--------------------------------------------------------------------------------------
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a: NumberInt("200") } );
+ use mycluster_mydb_regression_slot;
+ db.testing.updateOne( { a: NumberInt("200") }, { $set:  { a: NumberInt("500") } } );
+ use mycluster_mydb_regression_slot;
+ db.testing.deleteOne( { a: NumberInt("500") } );
+(6 rows)
+
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'actions', 'update', 'regress', 'true');
+                                         data                                         
+--------------------------------------------------------------------------------------
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a: NumberInt("200") } );
+ use mycluster_mydb_regression_slot;
+ db.testing.updateOne( { a: NumberInt("200") }, { $set:  { a: NumberInt("500") } } );
+ use mycluster_mydb_regression_slot;
+ db.testing.deleteOne( { a: NumberInt("500") } );
+(6 rows)
+
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'actions', 'delete', 'regress', 'true');
+                                         data                                         
+--------------------------------------------------------------------------------------
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a: NumberInt("200") } );
+ use mycluster_mydb_regression_slot;
+ db.testing.updateOne( { a: NumberInt("200") }, { $set:  { a: NumberInt("500") } } );
+ use mycluster_mydb_regression_slot;
+ db.testing.deleteOne( { a: NumberInt("500") } );
+(6 rows)
+
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'actions', 'truncate', 'regress', 'true');
+                                         data                                         
+--------------------------------------------------------------------------------------
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a: NumberInt("200") } );
+ use mycluster_mydb_regression_slot;
+ db.testing.updateOne( { a: NumberInt("200") }, { $set:  { a: NumberInt("500") } } );
+ use mycluster_mydb_regression_slot;
+ db.testing.deleteOne( { a: NumberInt("500") } );
+(6 rows)
+
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'actions', 'insert, update, delete, truncate', 'regress', 'true');
+                                         data                                         
+--------------------------------------------------------------------------------------
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a: NumberInt("200") } );
+ use mycluster_mydb_regression_slot;
+ db.testing.updateOne( { a: NumberInt("200") }, { $set:  { a: NumberInt("500") } } );
+ use mycluster_mydb_regression_slot;
+ db.testing.deleteOne( { a: NumberInt("500") } );
+(6 rows)
+
+-- peek changes with default action configuraiton
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'regress', 'true');
+                                         data                                         
+--------------------------------------------------------------------------------------
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a: NumberInt("200") } );
+ use mycluster_mydb_regression_slot;
+ db.testing.updateOne( { a: NumberInt("200") }, { $set:  { a: NumberInt("500") } } );
+ use mycluster_mydb_regression_slot;
+ db.testing.deleteOne( { a: NumberInt("500") } );
+(6 rows)
+
+-- peek changes with several configuration parameter combinations
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'include_cluster_name', 'true', 'regress', 'true');
+                                         data                                         
+--------------------------------------------------------------------------------------
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a: NumberInt("200") } );
+ use mycluster_mydb_regression_slot;
+ db.testing.updateOne( { a: NumberInt("200") }, { $set:  { a: NumberInt("500") } } );
+ use mycluster_mydb_regression_slot;
+ db.testing.deleteOne( { a: NumberInt("500") } );
+(6 rows)
+
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'skip_empty_xacts', 'true', 'regress', 'true');
+                                         data                                         
+--------------------------------------------------------------------------------------
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a: NumberInt("200") } );
+ use mycluster_mydb_regression_slot;
+ db.testing.updateOne( { a: NumberInt("200") }, { $set:  { a: NumberInt("500") } } );
+ use mycluster_mydb_regression_slot;
+ db.testing.deleteOne( { a: NumberInt("500") } );
+(6 rows)
+
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'only_local', 'true', 'regress', 'true');
+                                         data                                         
+--------------------------------------------------------------------------------------
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a: NumberInt("200") } );
+ use mycluster_mydb_regression_slot;
+ db.testing.updateOne( { a: NumberInt("200") }, { $set:  { a: NumberInt("500") } } );
+ use mycluster_mydb_regression_slot;
+ db.testing.deleteOne( { a: NumberInt("500") } );
+(6 rows)
+
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'use_transaction', 'true', 'regress', 'true');
+                                         data                                         
+--------------------------------------------------------------------------------------
+ session0regression_slot = db.getMongo().startSession();
+ session0regression_slot.startTransaction();
+ session0regression_slot.commitTransaction();
+ session0regression_slot.endSession();
+ session0regression_slot = db.getMongo().startSession();
+ session0regression_slot.startTransaction();
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a: NumberInt("200") } );
+ session0regression_slot.commitTransaction();
+ session0regression_slot.endSession();
+ session0regression_slot = db.getMongo().startSession();
+ session0regression_slot.startTransaction();
+ use mycluster_mydb_regression_slot;
+ db.testing.updateOne( { a: NumberInt("200") }, { $set:  { a: NumberInt("500") } } );
+ session0regression_slot.commitTransaction();
+ session0regression_slot.endSession();
+ session0regression_slot = db.getMongo().startSession();
+ session0regression_slot.startTransaction();
+ use mycluster_mydb_regression_slot;
+ db.testing.deleteOne( { a: NumberInt("500") } );
+ session0regression_slot.commitTransaction();
+ session0regression_slot.endSession();
+ session0regression_slot = db.getMongo().startSession();
+ session0regression_slot.startTransaction();
+ session0regression_slot.commitTransaction();
+ session0regression_slot.endSession();
+(26 rows)
+
+-- peek changes with invalid actions
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'actions', 'insert, xxx, delete, xxx', 'regress', 'true');
+ERROR:  could not parse value "xxx" for parameter "actions"
+DROP TABLE testing;
+SELECT 'end' FROM pg_drop_replication_slot('regression_slot');
+ ?column? 
+----------
+ end
+(1 row)
+
diff --git a/contrib/wal2mongo/expected/array.out b/contrib/wal2mongo/expected/array.out
new file mode 100644
index 0000000000..f5578e4c54
--- /dev/null
+++ b/contrib/wal2mongo/expected/array.out
@@ -0,0 +1,76 @@
+\set VERBOSITY terse
+-- predictability
+SET synchronous_commit = on;
+SELECT 'init' FROM pg_create_logical_replication_slot('regression_slot', 'wal2mongo');
+ ?column? 
+----------
+ init
+(1 row)
+
+-- create table with different numeric type
+CREATE TABLE tbl_array(id serial primary key, a bool[], c char[], d name[], e int2[], f int4[], g text[], h varchar[], i int8[], j float4[], k float8[], l timestamptz[], m numeric[], n uuid[] );
+-- different data types for array
+INSERT INTO tbl_array (a, c, d, e, f, g, h, i, j, k, l, m, n) VALUES(
+ARRAY[true, false], 
+ARRAY['c'::char,'h'::char], 
+ARRAY['student'::name, 'teacher'::name], 
+ARRAY['123'::int2, '456'::int2],
+ARRAY['123456789'::int4,'987654321'::int4],
+ARRAY['abc'::text, '123'::text],
+ARRAY['ABCD'::varchar, '1234'::varchar],
+ARRAY['112233445566778899'::int8, '998877665544332211'::int8],
+ARRAY['123.456'::float4, '2222.3333'::float4],
+ARRAY['123456.123'::float8, '654321.123'::float8],
+ARRAY['2020-03-30 10:18:40.12-07'::timestamptz, '2020-03-30 20:28:40.12-07'::timestamptz],
+ARRAY['123456789'::numeric, '987654321'::numeric],
+ARRAY['40e6215d-b5c6-4896-987c-f30f3678f608'::uuid, '3f333df6-90a4-4fda-8dd3-9485d27cee36'::uuid]
+);
+UPDATE tbl_array SET
+a=ARRAY[false, true], 
+c=ARRAY['h'::char, 'c'::char], 
+d=ARRAY['teacher'::name, 'student'::name], 
+e=ARRAY['456'::int2, '123'::int2],
+f=ARRAY['987654321'::int4, '123456789'::int4],
+g=ARRAY['123'::text, 'abc'::text],
+h=ARRAY['1234'::varchar, 'ABCD'::varchar],
+i=ARRAY['998877665544332211'::int8, '112233445566778899'::int8],
+j=ARRAY['2222.3333'::float4, '123.456'::float4],
+k=ARRAY['654321.123'::float8, '123456.123'::float8],
+l=ARRAY['2020-03-30 20:28:40.12-07'::timestamptz, '2020-03-30 10:18:40.12-07'::timestamptz],
+m=ARRAY['987654321'::numeric, '123456789'::numeric],
+n=ARRAY['3f333df6-90a4-4fda-8dd3-9485d27cee36'::uuid, '40e6215d-b5c6-4896-987c-f30f3678f608'::uuid]
+WHERE id=1;
+DELETE FROM tbl_array WHERE id = 1;
+TRUNCATE TABLE tbl_array;
+-- peek changes according to action configuration
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'regress', 'true');
+                                                                                                                                                                                                                                                                                                                                     data                                                                                                                                                                                                                                                                                                                                     
+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+ use mycluster_mydb_regression_slot;
+ db.tbl_array.insertOne( { id: NumberInt("1"), a:[true,false], c:["c","h"], d:["student","teacher"], e:[NumberInt(123),NumberInt(456)], f:[NumberInt(123456789),NumberInt(987654321)], g:["abc","123"], h:["ABCD","1234"], i:[NumberLong(112233445566778899),NumberLong(998877665544332211)], j:[123.456,2222.3333], k:[NumberDecimal("123456.123"),NumberDecimal("654321.123")], l:[ISODate("Mon Mar 30 10:18:40.12 2020 PDT"),ISODate("Mon Mar 30 20:28:40.12 2020 PDT")], m:[NumberDecimal("123456789"),NumberDecimal("987654321")], n:[UUID("40e6215d-b5c6-4896-987c-f30f3678f608"),UUID("3f333df6-90a4-4fda-8dd3-9485d27cee36")] } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_array.updateOne( { id: NumberInt("1") }, { $set:  { id: NumberInt("1"), a:[false,true], c:["h","c"], d:["teacher","student"], e:[NumberInt(456),NumberInt(123)], f:[NumberInt(987654321),NumberInt(123456789)], g:["123","abc"], h:["1234","ABCD"], i:[NumberLong(998877665544332211),NumberLong(112233445566778899)], j:[2222.3333,123.456], k:[NumberDecimal("654321.123"),NumberDecimal("123456.123")], l:[ISODate("Mon Mar 30 20:28:40.12 2020 PDT"),ISODate("Mon Mar 30 10:18:40.12 2020 PDT")], m:[NumberDecimal("987654321"),NumberDecimal("123456789")], n:[UUID("3f333df6-90a4-4fda-8dd3-9485d27cee36"),UUID("40e6215d-b5c6-4896-987c-f30f3678f608")] } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_array.deleteOne( { id: NumberInt("1") } );
+(6 rows)
+
+-- get changes according to action configuration
+SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'regress', 'true');
+                                                                                                                                                                                                                                                                                                                                     data                                                                                                                                                                                                                                                                                                                                     
+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+ use mycluster_mydb_regression_slot;
+ db.tbl_array.insertOne( { id: NumberInt("1"), a:[true,false], c:["c","h"], d:["student","teacher"], e:[NumberInt(123),NumberInt(456)], f:[NumberInt(123456789),NumberInt(987654321)], g:["abc","123"], h:["ABCD","1234"], i:[NumberLong(112233445566778899),NumberLong(998877665544332211)], j:[123.456,2222.3333], k:[NumberDecimal("123456.123"),NumberDecimal("654321.123")], l:[ISODate("Mon Mar 30 10:18:40.12 2020 PDT"),ISODate("Mon Mar 30 20:28:40.12 2020 PDT")], m:[NumberDecimal("123456789"),NumberDecimal("987654321")], n:[UUID("40e6215d-b5c6-4896-987c-f30f3678f608"),UUID("3f333df6-90a4-4fda-8dd3-9485d27cee36")] } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_array.updateOne( { id: NumberInt("1") }, { $set:  { id: NumberInt("1"), a:[false,true], c:["h","c"], d:["teacher","student"], e:[NumberInt(456),NumberInt(123)], f:[NumberInt(987654321),NumberInt(123456789)], g:["123","abc"], h:["1234","ABCD"], i:[NumberLong(998877665544332211),NumberLong(112233445566778899)], j:[2222.3333,123.456], k:[NumberDecimal("654321.123"),NumberDecimal("123456.123")], l:[ISODate("Mon Mar 30 20:28:40.12 2020 PDT"),ISODate("Mon Mar 30 10:18:40.12 2020 PDT")], m:[NumberDecimal("987654321"),NumberDecimal("123456789")], n:[UUID("3f333df6-90a4-4fda-8dd3-9485d27cee36"),UUID("40e6215d-b5c6-4896-987c-f30f3678f608")] } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_array.deleteOne( { id: NumberInt("1") } );
+(6 rows)
+
+-- drop table
+DROP TABLE tbl_array;
+SELECT 'end' FROM pg_drop_replication_slot('regression_slot');
+ ?column? 
+----------
+ end
+(1 row)
+
diff --git a/contrib/wal2mongo/expected/binData.out b/contrib/wal2mongo/expected/binData.out
new file mode 100644
index 0000000000..88345f705d
--- /dev/null
+++ b/contrib/wal2mongo/expected/binData.out
@@ -0,0 +1,69 @@
+\set VERBOSITY terse
+-- predictability
+SET synchronous_commit = on;
+SELECT 'init' FROM pg_create_logical_replication_slot('regression_slot', 'wal2mongo');
+ ?column? 
+----------
+ init
+(1 row)
+
+-- UUID
+CREATE TABLE tbl_uuid ( id serial PRIMARY KEY, a_uuid UUID NOT NULL );
+INSERT INTO tbl_uuid (a_uuid) VALUES('47deacb1-3ad0-4a0e-8254-9ad3f589c9f3') ;
+UPDATE tbl_uuid SET a_uuid = 'e7d8e462-12cc-49dc-aac2-2b5dccdabeda' WHERE id=1;
+DELETE FROM tbl_uuid WHERE id = 1;
+TRUNCATE TABLE tbl_uuid;
+-- BYTEA
+CREATE TABLE tbl_bytea ( id serial PRIMARY KEY, a_bytea bytea NOT NULL );
+ALTER TABLE tbl_bytea REPLICA IDENTITY FULL;
+INSERT INTO tbl_bytea(a_bytea) SELECT 'abc \153\154\155 \052\251\124'::bytea RETURNING a_bytea;
+         a_bytea          
+--------------------------
+ \x616263206b6c6d202aa954
+(1 row)
+
+UPDATE tbl_bytea SET a_bytea = SELECT '\134'::bytea RETURNING a_bytea;
+ERROR:  syntax error at or near "SELECT" at character 32
+DELETE FROM tbl_bytea WHERE id = 1;
+TRUNCATE TABLE tbl_bytea;
+-- peek changes according to action configuration
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'regress', 'true');
+                                                                   data                                                                    
+-------------------------------------------------------------------------------------------------------------------------------------------
+ use mycluster_mydb_regression_slot;
+ db.tbl_uuid.insertOne( { id: NumberInt("1"), a_uuid: UUID("47deacb1-3ad0-4a0e-8254-9ad3f589c9f3") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_uuid.updateOne( { id: NumberInt("1") }, { $set:  { id: NumberInt("1"), a_uuid: UUID("e7d8e462-12cc-49dc-aac2-2b5dccdabeda") } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_uuid.deleteOne( { id: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_bytea.insertOne( { id: NumberInt("1"), a_bytea: HexData(0, "616263206b6c6d202aa954") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_bytea.deleteOne( { id: NumberInt("1") } );
+(10 rows)
+
+-- get changes according to action configuration
+SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'regress', 'true');
+                                                                   data                                                                    
+-------------------------------------------------------------------------------------------------------------------------------------------
+ use mycluster_mydb_regression_slot;
+ db.tbl_uuid.insertOne( { id: NumberInt("1"), a_uuid: UUID("47deacb1-3ad0-4a0e-8254-9ad3f589c9f3") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_uuid.updateOne( { id: NumberInt("1") }, { $set:  { id: NumberInt("1"), a_uuid: UUID("e7d8e462-12cc-49dc-aac2-2b5dccdabeda") } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_uuid.deleteOne( { id: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_bytea.insertOne( { id: NumberInt("1"), a_bytea: HexData(0, "616263206b6c6d202aa954") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_bytea.deleteOne( { id: NumberInt("1") } );
+(10 rows)
+
+-- drop tables
+DROP TABLE tbl_uuid;
+DROP TABLE tbl_bytea;
+SELECT 'end' FROM pg_drop_replication_slot('regression_slot');
+ ?column? 
+----------
+ end
+(1 row)
+
diff --git a/contrib/wal2mongo/expected/binary.out b/contrib/wal2mongo/expected/binary.out
new file mode 100644
index 0000000000..5ba00efa43
--- /dev/null
+++ b/contrib/wal2mongo/expected/binary.out
@@ -0,0 +1,35 @@
+-- predictability
+SET synchronous_commit = on;
+SELECT 'init' FROM pg_create_logical_replication_slot('regression_slot', 'wal2mongo');
+ ?column? 
+----------
+ init
+(1 row)
+
+-- succeeds, textual plugin, textual consumer
+SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'force_binary', '0');
+ data 
+------
+(0 rows)
+
+-- fails, binary plugin, textual consumer
+SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'force_binary', '1');
+ERROR:  logical decoding output plugin "wal2mongo" produces binary output, but function "pg_logical_slot_get_changes(name,pg_lsn,integer,text[])" expects textual data
+-- succeeds, textual plugin, binary consumer
+SELECT data FROM pg_logical_slot_get_binary_changes('regression_slot', NULL, NULL, 'force_binary', '0');
+ data 
+------
+(0 rows)
+
+-- succeeds, binary plugin, binary consumer
+SELECT data FROM pg_logical_slot_get_binary_changes('regression_slot', NULL, NULL, 'force_binary', '1');
+ data 
+------
+(0 rows)
+
+SELECT 'init' FROM pg_drop_replication_slot('regression_slot');
+ ?column? 
+----------
+ init
+(1 row)
+
diff --git a/contrib/wal2mongo/expected/boolean.out b/contrib/wal2mongo/expected/boolean.out
new file mode 100644
index 0000000000..45110f9628
--- /dev/null
+++ b/contrib/wal2mongo/expected/boolean.out
@@ -0,0 +1,324 @@
+\set VERBOSITY terse
+-- predictability
+SET synchronous_commit = on;
+SELECT 'init' FROM pg_create_logical_replication_slot('regression_slot', 'wal2mongo');
+ ?column? 
+----------
+ init
+(1 row)
+
+-- create table with boolean type
+CREATE TABLE tbl_boolean (a integer primary key, b BOOLEAN);
+-- true
+INSERT INTO tbl_boolean (a, b) VALUES(1, true);
+UPDATE tbl_boolean SET b = false WHERE a = 1;
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+-- 'true'
+INSERT INTO tbl_boolean (a, b) VALUES(1, 'true');
+UPDATE tbl_boolean SET b = 'false' WHERE a = 1;
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+-- 't'
+INSERT INTO tbl_boolean (a, b) VALUES(1, 't');
+UPDATE tbl_boolean SET b = 'f' WHERE a = 1;
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+-- TRUE
+INSERT INTO tbl_boolean (a, b) VALUES(1, TRUE);
+UPDATE tbl_boolean SET b = TRUE WHERE a = 1;
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+-- 'TRUE'
+INSERT INTO tbl_boolean (a, b) VALUES(1, 'TRUE');
+UPDATE tbl_boolean SET b = 'TRUE' WHERE a = 1;
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+-- 'T'
+INSERT INTO tbl_boolean (a, b) VALUES(1, 'T');
+UPDATE tbl_boolean SET b = 'T' WHERE a = 1;
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+-- 'on'
+INSERT INTO tbl_boolean (a, b) VALUES(1, 'on');
+UPDATE tbl_boolean SET b = 'off' WHERE a = 1;
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+-- '1'
+INSERT INTO tbl_boolean (a, b) VALUES(1, '1');
+UPDATE tbl_boolean SET b = '0' WHERE a = 1;
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+-- false
+INSERT INTO tbl_boolean (a, b) VALUES(1, false);
+UPDATE tbl_boolean SET b = true WHERE a = 1;
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+-- 'false'
+INSERT INTO tbl_boolean (a, b) VALUES(1, 'false');
+UPDATE tbl_boolean SET b = 'true' WHERE a = 1;
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+-- 'f'
+INSERT INTO tbl_boolean (a, b) VALUES(1, 'f');
+UPDATE tbl_boolean SET b = 't' WHERE a = 1;
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+-- FALSE
+INSERT INTO tbl_boolean (a, b) VALUES(1, FALSE);
+UPDATE tbl_boolean SET b = TRUE WHERE a = 1;
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+-- 'FALSE'
+INSERT INTO tbl_boolean (a, b) VALUES(1, 'FALSE');
+UPDATE tbl_boolean SET b = 'TRUE' WHERE a = 1;
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+-- 'F'
+INSERT INTO tbl_boolean (a, b) VALUES(1, 'F');
+UPDATE tbl_boolean SET b = 'T' WHERE a = 1;
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+-- 'off'
+INSERT INTO tbl_boolean (a, b) VALUES(1, 'off');
+UPDATE tbl_boolean SET b = 'on' WHERE a = 1;
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+-- '0'
+INSERT INTO tbl_boolean (a, b) VALUES(1, '0');
+UPDATE tbl_boolean SET b = '1' WHERE a = 1;
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+-- 'on' exception
+INSERT INTO tbl_boolean (a, b) VALUES(1, on);
+ERROR:  syntax error at or near "on" at character 42
+UPDATE tbl_boolean SET b = off WHERE a = 1;
+ERROR:  column "off" does not exist at character 28
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+-- 'enable' exception
+INSERT INTO tbl_boolean (a, b) VALUES(1, 'enable');
+ERROR:  invalid input syntax for type boolean: "enable" at character 42
+UPDATE tbl_boolean SET b = 'disable' WHERE a = 1;
+ERROR:  invalid input syntax for type boolean: "disable" at character 28
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+-- 'disable' exception
+INSERT INTO tbl_boolean (a, b) VALUES(1, 'disable');
+ERROR:  invalid input syntax for type boolean: "disable" at character 42
+UPDATE tbl_boolean SET b = 'enable' WHERE a = 1;
+ERROR:  invalid input syntax for type boolean: "enable" at character 28
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+-- peek changes according to action configuration
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'regress', 'true');
+                                             data                                              
+-----------------------------------------------------------------------------------------------
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.insertOne( { a: NumberInt("1"), b:true } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.updateOne( { a: NumberInt("1") }, { $set:  { a: NumberInt("1"), b:false } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.deleteOne( { a: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.insertOne( { a: NumberInt("1"), b:true } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.updateOne( { a: NumberInt("1") }, { $set:  { a: NumberInt("1"), b:false } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.deleteOne( { a: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.insertOne( { a: NumberInt("1"), b:true } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.updateOne( { a: NumberInt("1") }, { $set:  { a: NumberInt("1"), b:false } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.deleteOne( { a: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.insertOne( { a: NumberInt("1"), b:true } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.updateOne( { a: NumberInt("1") }, { $set:  { a: NumberInt("1"), b:true } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.deleteOne( { a: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.insertOne( { a: NumberInt("1"), b:true } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.updateOne( { a: NumberInt("1") }, { $set:  { a: NumberInt("1"), b:true } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.deleteOne( { a: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.insertOne( { a: NumberInt("1"), b:true } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.updateOne( { a: NumberInt("1") }, { $set:  { a: NumberInt("1"), b:true } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.deleteOne( { a: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.insertOne( { a: NumberInt("1"), b:true } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.updateOne( { a: NumberInt("1") }, { $set:  { a: NumberInt("1"), b:false } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.deleteOne( { a: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.insertOne( { a: NumberInt("1"), b:true } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.updateOne( { a: NumberInt("1") }, { $set:  { a: NumberInt("1"), b:false } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.deleteOne( { a: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.insertOne( { a: NumberInt("1"), b:false } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.updateOne( { a: NumberInt("1") }, { $set:  { a: NumberInt("1"), b:true } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.deleteOne( { a: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.insertOne( { a: NumberInt("1"), b:false } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.updateOne( { a: NumberInt("1") }, { $set:  { a: NumberInt("1"), b:true } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.deleteOne( { a: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.insertOne( { a: NumberInt("1"), b:false } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.updateOne( { a: NumberInt("1") }, { $set:  { a: NumberInt("1"), b:true } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.deleteOne( { a: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.insertOne( { a: NumberInt("1"), b:false } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.updateOne( { a: NumberInt("1") }, { $set:  { a: NumberInt("1"), b:true } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.deleteOne( { a: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.insertOne( { a: NumberInt("1"), b:false } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.updateOne( { a: NumberInt("1") }, { $set:  { a: NumberInt("1"), b:true } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.deleteOne( { a: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.insertOne( { a: NumberInt("1"), b:false } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.updateOne( { a: NumberInt("1") }, { $set:  { a: NumberInt("1"), b:true } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.deleteOne( { a: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.insertOne( { a: NumberInt("1"), b:false } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.updateOne( { a: NumberInt("1") }, { $set:  { a: NumberInt("1"), b:true } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.deleteOne( { a: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.insertOne( { a: NumberInt("1"), b:false } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.updateOne( { a: NumberInt("1") }, { $set:  { a: NumberInt("1"), b:true } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.deleteOne( { a: NumberInt("1") } );
+(96 rows)
+
+-- get changes according to action configuration
+SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'regress', 'true');
+                                             data                                              
+-----------------------------------------------------------------------------------------------
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.insertOne( { a: NumberInt("1"), b:true } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.updateOne( { a: NumberInt("1") }, { $set:  { a: NumberInt("1"), b:false } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.deleteOne( { a: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.insertOne( { a: NumberInt("1"), b:true } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.updateOne( { a: NumberInt("1") }, { $set:  { a: NumberInt("1"), b:false } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.deleteOne( { a: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.insertOne( { a: NumberInt("1"), b:true } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.updateOne( { a: NumberInt("1") }, { $set:  { a: NumberInt("1"), b:false } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.deleteOne( { a: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.insertOne( { a: NumberInt("1"), b:true } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.updateOne( { a: NumberInt("1") }, { $set:  { a: NumberInt("1"), b:true } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.deleteOne( { a: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.insertOne( { a: NumberInt("1"), b:true } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.updateOne( { a: NumberInt("1") }, { $set:  { a: NumberInt("1"), b:true } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.deleteOne( { a: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.insertOne( { a: NumberInt("1"), b:true } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.updateOne( { a: NumberInt("1") }, { $set:  { a: NumberInt("1"), b:true } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.deleteOne( { a: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.insertOne( { a: NumberInt("1"), b:true } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.updateOne( { a: NumberInt("1") }, { $set:  { a: NumberInt("1"), b:false } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.deleteOne( { a: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.insertOne( { a: NumberInt("1"), b:true } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.updateOne( { a: NumberInt("1") }, { $set:  { a: NumberInt("1"), b:false } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.deleteOne( { a: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.insertOne( { a: NumberInt("1"), b:false } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.updateOne( { a: NumberInt("1") }, { $set:  { a: NumberInt("1"), b:true } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.deleteOne( { a: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.insertOne( { a: NumberInt("1"), b:false } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.updateOne( { a: NumberInt("1") }, { $set:  { a: NumberInt("1"), b:true } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.deleteOne( { a: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.insertOne( { a: NumberInt("1"), b:false } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.updateOne( { a: NumberInt("1") }, { $set:  { a: NumberInt("1"), b:true } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.deleteOne( { a: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.insertOne( { a: NumberInt("1"), b:false } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.updateOne( { a: NumberInt("1") }, { $set:  { a: NumberInt("1"), b:true } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.deleteOne( { a: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.insertOne( { a: NumberInt("1"), b:false } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.updateOne( { a: NumberInt("1") }, { $set:  { a: NumberInt("1"), b:true } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.deleteOne( { a: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.insertOne( { a: NumberInt("1"), b:false } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.updateOne( { a: NumberInt("1") }, { $set:  { a: NumberInt("1"), b:true } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.deleteOne( { a: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.insertOne( { a: NumberInt("1"), b:false } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.updateOne( { a: NumberInt("1") }, { $set:  { a: NumberInt("1"), b:true } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.deleteOne( { a: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.insertOne( { a: NumberInt("1"), b:false } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.updateOne( { a: NumberInt("1") }, { $set:  { a: NumberInt("1"), b:true } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_boolean.deleteOne( { a: NumberInt("1") } );
+(96 rows)
+
+-- peek changes with invalid actions
+DROP TABLE tbl_boolean;
+SELECT 'end' FROM pg_drop_replication_slot('regression_slot');
+ ?column? 
+----------
+ end
+(1 row)
+
diff --git a/contrib/wal2mongo/expected/identity.out b/contrib/wal2mongo/expected/identity.out
new file mode 100644
index 0000000000..a412394ae4
--- /dev/null
+++ b/contrib/wal2mongo/expected/identity.out
@@ -0,0 +1,89 @@
+\set VERBOSITY terse
+-- predictability
+SET synchronous_commit = on;
+SELECT 'init' FROM pg_create_logical_replication_slot('regression_slot', 'wal2mongo');
+ ?column? 
+----------
+ init
+(1 row)
+
+-- Replica identity nothing
+CREATE TABLE testing (a varchar(30) primary key, b INT, c INT);
+ALTER TABLE testing REPLICA IDENTITY NOTHING;
+BEGIN;
+INSERT INTO testing VALUES('aaa', 123, 456);
+UPDATE testing set b = 789 where a = 'aaa';
+UPDATE testing set a = 'bbb';
+DELETE from testing where a = 'bbb';
+COMMIT;
+-- Replica identity default
+BEGIN;
+ALTER TABLE testing REPLICA IDENTITY DEFAULT;
+INSERT INTO testing VALUES('aaa', 123, 456);
+UPDATE testing set b = 789 where a = 'aaa';
+UPDATE testing set a = 'bbb';
+DELETE from testing where a = 'bbb';
+COMMIT;
+-- Replica identity full
+BEGIN;
+ALTER TABLE testing REPLICA IDENTITY FULL;
+INSERT INTO testing VALUES('aaa', 123, 456);
+UPDATE testing set b = 789 where a = 'aaa';
+UPDATE testing set a = 'bbb';
+DELETE from testing where a = 'bbb';
+COMMIT;
+-- Replica identity index
+CREATE INDEX idx_test ON testing(b);
+ALTER TABLE testing REPLICA IDENTITY INDEX;
+ERROR:  syntax error at or near "INDEX" at character 38
+INSERT INTO testing VALUES('aaa', 123, 456);
+UPDATE testing set b = 789 where a = 'aaa';
+UPDATE testing set a = 'bbb';
+DELETE from testing where a = 'bbb';
+COMMIT;
+WARNING:  there is no transaction in progress
+-- get changes
+SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'regress', 'true', 'skip_empty_xacts', 'true');
+                                                  data                                                  
+--------------------------------------------------------------------------------------------------------
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a:"aaa", b: NumberInt("123"), c: NumberInt("456") } );
+ use mycluster_mydb_regression_slot;
+ db.testing.updateOne( { a:"aaa" }, { $set:  { a:"aaa", b: NumberInt("789"), c: NumberInt("456") } } );
+ use mycluster_mydb_regression_slot;
+ db.testing.updateOne( { a:"bbb" }, { $set:  { a:"bbb", b: NumberInt("789"), c: NumberInt("456") } } );
+ use mycluster_mydb_regression_slot;
+ db.testing.deleteOne( (no-tuple-data) );
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a:"aaa", b: NumberInt("123"), c: NumberInt("456") } );
+ use mycluster_mydb_regression_slot;
+ db.testing.updateOne( { a:"aaa" }, { $set:  { a:"aaa", b: NumberInt("789"), c: NumberInt("456") } } );
+ use mycluster_mydb_regression_slot;
+ db.testing.updateOne( { a:"aaa" }, { $set:  { a:"bbb", b: NumberInt("789"), c: NumberInt("456") } } );
+ use mycluster_mydb_regression_slot;
+ db.testing.deleteOne( { a:"bbb" } );
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a:"aaa", b: NumberInt("123"), c: NumberInt("456") } );
+ use mycluster_mydb_regression_slot;
+ db.testing.updateOne( { a:"aaa" }, { $set:  { a:"aaa", b: NumberInt("789"), c: NumberInt("456") } } );
+ use mycluster_mydb_regression_slot;
+ db.testing.updateOne( { a:"aaa" }, { $set:  { a:"bbb", b: NumberInt("789"), c: NumberInt("456") } } );
+ use mycluster_mydb_regression_slot;
+ db.testing.deleteOne( { a:"bbb" } );
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a:"aaa", b: NumberInt("123"), c: NumberInt("456") } );
+ use mycluster_mydb_regression_slot;
+ db.testing.updateOne( { a:"aaa" }, { $set:  { a:"aaa", b: NumberInt("789"), c: NumberInt("456") } } );
+ use mycluster_mydb_regression_slot;
+ db.testing.updateOne( { a:"aaa" }, { $set:  { a:"bbb", b: NumberInt("789"), c: NumberInt("456") } } );
+ use mycluster_mydb_regression_slot;
+ db.testing.deleteOne( { a:"bbb" } );
+(32 rows)
+
+DROP TABLE testing;
+SELECT 'end' FROM pg_drop_replication_slot('regression_slot');
+ ?column? 
+----------
+ end
+(1 row)
+
diff --git a/contrib/wal2mongo/expected/json.out b/contrib/wal2mongo/expected/json.out
new file mode 100755
index 0000000000..2440eda8bf
--- /dev/null
+++ b/contrib/wal2mongo/expected/json.out
@@ -0,0 +1,114 @@
+\set VERBOSITY terse
+-- predictability
+SET synchronous_commit = on;
+SELECT 'init' FROM pg_create_logical_replication_slot('regression_slot', 'wal2mongo');
+ ?column? 
+----------
+ init
+(1 row)
+
+CREATE TABLE testing (a integer primary key, 
+					  j1 json, 
+					  j2 jsonb,
+					  j3 jsonpath,
+					  j4 json[],
+					  j5 jsonb[]);
+-- JSON data type
+INSERT INTO testing (a, j1) VALUES(1, '{"customer": "John", "items":{"product":"beer","qty":20}}');
+INSERT INTO testing (a, j1) VALUES(2, '{"customer": "Michael", "items":[{"product":"vodka","qty":5},{"product":"whiskey","qty":10},{"product":"cooler","qty":10}]}');
+INSERT INTO testing (a, j1) VALUES(3, '{"customer": "Joe", "items":{"product":"wine","qty":20}}');
+UPDATE testing set j1='{"customer": "Michael", "items":[{"product":"vodka","qty":5},{"product":"whiskey","qty":10}]}' where a = 3;
+DELETE FROM testing where a = 1;
+-- JSONB data type
+INSERT INTO testing (a, j2) VALUES(4, '{"customer": "John", "items":{"product":"beer","qty":20}}');
+INSERT INTO testing (a, j2) VALUES(5, '{"customer": "Michael", "items":[{"product":"vodka","qty":5},{"product":"whiskey","qty":10},{"product":"cooler","qty":10}]}');
+INSERT INTO testing (a, j2) VALUES(6, '{"customer": "Joe", "items":{"product":"wine","qty":20}}');
+UPDATE testing set j2='{"customer": "Michael", "items":[{"product":"vodka","qty":5},{"product":"whiskey","qty":10}]}' where a = 3;
+DELETE FROM testing where a = 1;
+-- JSONPATH data type
+INSERT INTO testing (a, j3) VALUES(7, '$.equipment.rings[*] ? (@.track.segments > 1)');
+UPDATE testing set j3 = '$.equipment.rings[*]' where a = 7;
+DELETE from testing where a = 7;
+-- JSON[] data type
+INSERT into testing (a, j4) VALUES 
+( 
+	8,
+	array[ 
+		'{"customer": "Cary", "items":{"product":"beer","qty":1000}}',
+		'{"customer": "John", "items":{"product":"beer","qty":2000}}',
+		'{"customer": "David", "items":{"product":"beer","qty":3000}}'
+	]::json[] 
+);
+UPDATE testing set j4 = 
+array[ 
+		'{"customer": "Cary"}',
+		'{"customer": "John"}',
+		'{"customer": "David"}'
+]::json[] where a = 8;
+DELETE FROM testing where a = 8;
+-- JSONB[] data type
+INSERT into testing (a, j5) VALUES 
+( 
+	9,
+	array[ 
+		'{"customer": "Cary", "items":{"product":"beer","qty":1000}}',
+		'{"customer": "John", "items":{"product":"beer","qty":2000}}',
+		'{"customer": "David", "items":{"product":"beer","qty":3000}}'
+	]::json[] 
+);
+UPDATE testing set j5 = 
+array[ 
+		'{"customer": "Cary"}',
+		'{"customer": "John"}',
+		'{"customer": "David"}'
+]::json[] where a = 9;
+DELETE FROM testing where a = 9;
+-- get the changes
+SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'use_transaction', 'false', 'regress', 'true');
+                                                                                                                                                          data                                                                                                                                                           
+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a: NumberInt("1"), j1:{"customer": "John", "items":{"product":"beer","qty":20}} } );
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a: NumberInt("2"), j1:{"customer": "Michael", "items":[{"product":"vodka","qty":5},{"product":"whiskey","qty":10},{"product":"cooler","qty":10}]} } );
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a: NumberInt("3"), j1:{"customer": "Joe", "items":{"product":"wine","qty":20}} } );
+ use mycluster_mydb_regression_slot;
+ db.testing.updateOne( { a: NumberInt("3") }, { $set:  { a: NumberInt("3"), j1:{"customer": "Michael", "items":[{"product":"vodka","qty":5},{"product":"whiskey","qty":10}]}, j2:null, j3:null, j4:null, j5:null } } );
+ use mycluster_mydb_regression_slot;
+ db.testing.deleteOne( { a: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a: NumberInt("4"), j2:{"items": {"qty": 20, "product": "beer"}, "customer": "John"} } );
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a: NumberInt("5"), j2:{"items": [{"qty": 5, "product": "vodka"}, {"qty": 10, "product": "whiskey"}, {"qty": 10, "product": "cooler"}], "customer": "Michael"} } );
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a: NumberInt("6"), j2:{"items": {"qty": 20, "product": "wine"}, "customer": "Joe"} } );
+ use mycluster_mydb_regression_slot;
+ db.testing.updateOne( { a: NumberInt("3") }, { $set:  { a: NumberInt("3"), j1:{"customer": "Michael", "items":[{"product":"vodka","qty":5},{"product":"whiskey","qty":10}]}, j2:{"items": [{"qty": 5, "product": "vodka"}, {"qty": 10, "product": "whiskey"}], "customer": "Michael"}, j3:null, j4:null, j5:null } } );
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a: NumberInt("7"), j3:"$.equipment.rings[*]?(@.track.segments > 1)" } );
+ use mycluster_mydb_regression_slot;
+ db.testing.updateOne( { a: NumberInt("7") }, { $set:  { a: NumberInt("7"), j1:null, j2:null, j3:"$.equipment.rings[*]", j4:null, j5:null } } );
+ use mycluster_mydb_regression_slot;
+ db.testing.deleteOne( { a: NumberInt("7") } );
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a: NumberInt("8"), j4:[{"customer": "Cary", "items":{"product":"beer","qty":1000}},{"customer": "John", "items":{"product":"beer","qty":2000}},{"customer": "David", "items":{"product":"beer","qty":3000}}] } );
+ use mycluster_mydb_regression_slot;
+ db.testing.updateOne( { a: NumberInt("8") }, { $set:  { a: NumberInt("8"), j1:null, j2:null, j3:null, j4:[{"customer": "Cary"},{"customer": "John"},{"customer": "David"}], j5:null } } );
+ use mycluster_mydb_regression_slot;
+ db.testing.deleteOne( { a: NumberInt("8") } );
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a: NumberInt("9"), j5:[{"items": {"qty": 1000, "product": "beer"}, "customer": "Cary"},{"items": {"qty": 2000, "product": "beer"}, "customer": "John"},{"items": {"qty": 3000, "product": "beer"}, "customer": "David"}] } );
+ use mycluster_mydb_regression_slot;
+ db.testing.updateOne( { a: NumberInt("9") }, { $set:  { a: NumberInt("9"), j1:null, j2:null, j3:null, j4:null, j5:[{"customer": "Cary"},{"customer": "John"},{"customer": "David"}] } } );
+ use mycluster_mydb_regression_slot;
+ db.testing.deleteOne( { a: NumberInt("9") } );
+(36 rows)
+
+DROP TABLE testing;
+SELECT 'end' FROM pg_drop_replication_slot('regression_slot');
+ ?column? 
+----------
+ end
+(1 row)
+
diff --git a/contrib/wal2mongo/expected/numeric.out b/contrib/wal2mongo/expected/numeric.out
new file mode 100644
index 0000000000..84cb3656c9
--- /dev/null
+++ b/contrib/wal2mongo/expected/numeric.out
@@ -0,0 +1,65 @@
+\set VERBOSITY terse
+-- predictability
+SET synchronous_commit = on;
+SELECT 'init' FROM pg_create_logical_replication_slot('regression_slot', 'wal2mongo');
+ ?column? 
+----------
+ init
+(1 row)
+
+-- create table with different numeric type
+CREATE TABLE tbl_int(id serial primary key, a smallint, b integer, c serial, d real, e bigint, f bigserial, g double precision, h decimal, i numeric);
+-- minumum values
+INSERT INTO tbl_int values(1, -32768, -2147483648, 1, -0.123456, -9223372036854775808, 1, -1.123456789123456, -1234567890.1234567891, -9876543210.0987654321);
+UPDATE tbl_int SET a=a+1, b=b+1, c=c+1, d=d+1, e=e+1, f=f+1, g=g+1, h=h+1, i=i+1 WHERE id=1;
+DELETE FROM tbl_int WHERE id = 1;
+TRUNCATE TABLE tbl_int;
+-- maximum values
+INSERT INTO tbl_int values(1, 32767, 2147483647, 2147483647, 0.123456, 9223372036854775807, 9223372036854775807, 1.123456789123456, 1234567890.1234567891, 9876543210.0987654321);
+UPDATE tbl_int SET a=a-1, b=b-1, c=c-1, d=d-1, e=e-1, f=f-1, g=g-1, h=h-1, i=i-1 WHERE id=1;
+DELETE FROM tbl_int WHERE id = 1;
+TRUNCATE TABLE tbl_int;
+-- peek changes according to action configuration
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'regress', 'true');
+                                                                                                                                                                                           data                                                                                                                                                                                            
+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+ use mycluster_mydb_regression_slot;
+ db.tbl_int.insertOne( { id: NumberInt("1"), a: NumberInt("-32768"), b: NumberInt("-2147483648"), c: NumberInt("1"), d:-0.123456, e: NumberLong("-9223372036854775808"), f: NumberLong("1"), g: NumberDecimal("-1.123456789123456"), h: NumberDecimal("-1234567890.1234567891"), i: NumberDecimal("-9876543210.0987654321") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_int.updateOne( { id: NumberInt("1") }, { $set:  { id: NumberInt("1"), a: NumberInt("-32767"), b: NumberInt("-2147483647"), c: NumberInt("2"), d:0.876544, e: NumberLong("-9223372036854775807"), f: NumberLong("2"), g: NumberDecimal("-0.12345678912345592"), h: NumberDecimal("-1234567889.1234567891"), i: NumberDecimal("-9876543209.0987654321") } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_int.deleteOne( { id: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_int.insertOne( { id: NumberInt("1"), a: NumberInt("32767"), b: NumberInt("2147483647"), c: NumberInt("2147483647"), d:0.123456, e: NumberLong("9223372036854775807"), f: NumberLong("9223372036854775807"), g: NumberDecimal("1.123456789123456"), h: NumberDecimal("1234567890.1234567891"), i: NumberDecimal("9876543210.0987654321") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_int.updateOne( { id: NumberInt("1") }, { $set:  { id: NumberInt("1"), a: NumberInt("32766"), b: NumberInt("2147483646"), c: NumberInt("2147483646"), d:-0.876544, e: NumberLong("9223372036854775806"), f: NumberLong("9223372036854775806"), g: NumberDecimal("0.12345678912345592"), h: NumberDecimal("1234567889.1234567891"), i: NumberDecimal("9876543209.0987654321") } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_int.deleteOne( { id: NumberInt("1") } );
+(12 rows)
+
+-- get changes according to action configuration
+SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'regress', 'true');
+                                                                                                                                                                                           data                                                                                                                                                                                            
+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+ use mycluster_mydb_regression_slot;
+ db.tbl_int.insertOne( { id: NumberInt("1"), a: NumberInt("-32768"), b: NumberInt("-2147483648"), c: NumberInt("1"), d:-0.123456, e: NumberLong("-9223372036854775808"), f: NumberLong("1"), g: NumberDecimal("-1.123456789123456"), h: NumberDecimal("-1234567890.1234567891"), i: NumberDecimal("-9876543210.0987654321") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_int.updateOne( { id: NumberInt("1") }, { $set:  { id: NumberInt("1"), a: NumberInt("-32767"), b: NumberInt("-2147483647"), c: NumberInt("2"), d:0.876544, e: NumberLong("-9223372036854775807"), f: NumberLong("2"), g: NumberDecimal("-0.12345678912345592"), h: NumberDecimal("-1234567889.1234567891"), i: NumberDecimal("-9876543209.0987654321") } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_int.deleteOne( { id: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_int.insertOne( { id: NumberInt("1"), a: NumberInt("32767"), b: NumberInt("2147483647"), c: NumberInt("2147483647"), d:0.123456, e: NumberLong("9223372036854775807"), f: NumberLong("9223372036854775807"), g: NumberDecimal("1.123456789123456"), h: NumberDecimal("1234567890.1234567891"), i: NumberDecimal("9876543210.0987654321") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_int.updateOne( { id: NumberInt("1") }, { $set:  { id: NumberInt("1"), a: NumberInt("32766"), b: NumberInt("2147483646"), c: NumberInt("2147483646"), d:-0.876544, e: NumberLong("9223372036854775806"), f: NumberLong("9223372036854775806"), g: NumberDecimal("0.12345678912345592"), h: NumberDecimal("1234567889.1234567891"), i: NumberDecimal("9876543209.0987654321") } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_int.deleteOne( { id: NumberInt("1") } );
+(12 rows)
+
+-- drop table
+DROP TABLE tbl_int;
+SELECT 'end' FROM pg_drop_replication_slot('regression_slot');
+ ?column? 
+----------
+ end
+(1 row)
+
diff --git a/contrib/wal2mongo/expected/pkey.out b/contrib/wal2mongo/expected/pkey.out
new file mode 100644
index 0000000000..c4951dd723
--- /dev/null
+++ b/contrib/wal2mongo/expected/pkey.out
@@ -0,0 +1,123 @@
+\set VERBOSITY terse
+-- predictability
+SET synchronous_commit = on;
+SELECT 'init' FROM pg_create_logical_replication_slot('regression_slot', 'wal2mongo');
+ ?column? 
+----------
+ init
+(1 row)
+
+CREATE TABLE testing_one_pkey (
+a smallserial PRIMARY KEY,
+b smallint,
+c int,
+d bigint,
+e int,
+f real,
+g double precision,
+h char(20),
+i varchar(30),
+j text
+);
+CREATE TABLE testing_multi_pkey (
+a smallserial,
+b smallint,
+c int,
+d bigint,
+e int,
+f real,
+g double precision,
+h char(20),
+i varchar(30),
+j text,
+PRIMARY KEY(a, b, c)
+);
+CREATE TABLE testing_no_pkey (
+a smallserial,
+b smallint,
+c int,
+d bigint,
+e int,
+f real,
+g double precision,
+h char(20),
+i varchar(30),
+j text
+);
+CREATE TABLE testing_unique (
+a smallserial,
+b smallint,
+c int,
+d bigint,
+e int,
+f real,
+g double precision,
+h char(20),
+i varchar(30),
+j text,
+UNIQUE(f, g)
+);
+INSERT INTO testing_one_pkey (b, c, d, e, f, g, h, i, j) VALUES (1, 2, 33, 555, 666.777777777, 3.33, 'testval1', 'testval2', 'testval3');
+INSERT INTO testing_multi_pkey (b, c, d, e, f, g, h, i, j) VALUES (1, 2, 33, 555, 666.777777777, 3.33, 'testval1', 'testval2', 'testval3');
+INSERT INTO testing_no_pkey (b, c, d, e, f, g, h, i, j) VALUES (1, 2, 33, 555, 666.777777777, 3.33, 'testval1', 'testval2', 'testval3');
+INSERT INTO testing_unique (b, c, d, e, f, g, h, i, j) VALUES (1, 2, 33, 555, 666.777777777, 3.33, 'testval1', 'testval2', 'testval3');
+-- non pkey change
+UPDATE testing_one_pkey SET f = 777.888888888 WHERE b = 1;
+-- pkey change
+UPDATE testing_one_pkey SET a = 14 WHERE b = 1;  
+-- non pkey change
+UPDATE testing_multi_pkey SET f = 777.888888888 WHERE b = 1;
+-- some pkeys change
+UPDATE testing_multi_pkey SET a = 14, c = 14 WHERE b = 1; 
+-- all pkeys change
+UPDATE testing_multi_pkey SET a = 15, b = 15, c = 15 WHERE b = 1; 
+-- no pkey
+UPDATE testing_no_pkey SET h = 'changed' WHERE b = 1;
+-- non unique change
+UPDATE testing_unique SET h = 'changed' WHERE b = 1;
+-- one unique val change
+UPDATE testing_unique SET f = 888.888888888 WHERE b = 1;
+-- all unique vals change
+UPDATE testing_unique SET f = 888.888888888, g = 6.66 WHERE b = 1;
+-- get changes
+SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'regress', 'true', 'skip_empty_xacts', 'true');
+                                                                                                                                                        data                                                                                                                                                        
+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+ use mycluster_mydb_regression_slot;
+ db.testing_one_pkey.insertOne( { a: NumberInt("1"), b: NumberInt("1"), c: NumberInt("2"), d: NumberLong("33"), e: NumberInt("555"), f:666.7778, g: NumberDecimal("3.33"), h:"testval1            ", i:"testval2", j:"testval3" } );
+ use mycluster_mydb_regression_slot;
+ db.testing_multi_pkey.insertOne( { a: NumberInt("1"), b: NumberInt("1"), c: NumberInt("2"), d: NumberLong("33"), e: NumberInt("555"), f:666.7778, g: NumberDecimal("3.33"), h:"testval1            ", i:"testval2", j:"testval3" } );
+ use mycluster_mydb_regression_slot;
+ db.testing_no_pkey.insertOne( { a: NumberInt("1"), b: NumberInt("1"), c: NumberInt("2"), d: NumberLong("33"), e: NumberInt("555"), f:666.7778, g: NumberDecimal("3.33"), h:"testval1            ", i:"testval2", j:"testval3" } );
+ use mycluster_mydb_regression_slot;
+ db.testing_unique.insertOne( { a: NumberInt("1"), b: NumberInt("1"), c: NumberInt("2"), d: NumberLong("33"), e: NumberInt("555"), f:666.7778, g: NumberDecimal("3.33"), h:"testval1            ", i:"testval2", j:"testval3" } );
+ use mycluster_mydb_regression_slot;
+ db.testing_one_pkey.updateOne( { a: NumberInt("1") }, { $set:  { a: NumberInt("1"), b: NumberInt("1"), c: NumberInt("2"), d: NumberLong("33"), e: NumberInt("555"), f:777.8889, g: NumberDecimal("3.33"), h:"testval1            ", i:"testval2", j:"testval3" } } );
+ use mycluster_mydb_regression_slot;
+ db.testing_one_pkey.updateOne( { a: NumberInt("1") }, { $set:  { a: NumberInt("14"), b: NumberInt("1"), c: NumberInt("2"), d: NumberLong("33"), e: NumberInt("555"), f:777.8889, g: NumberDecimal("3.33"), h:"testval1            ", i:"testval2", j:"testval3" } } );
+ use mycluster_mydb_regression_slot;
+ db.testing_multi_pkey.updateOne( { a: NumberInt("1"), b: NumberInt("1"), c: NumberInt("2") }, { $set:  { a: NumberInt("1"), b: NumberInt("1"), c: NumberInt("2"), d: NumberLong("33"), e: NumberInt("555"), f:777.8889, g: NumberDecimal("3.33"), h:"testval1            ", i:"testval2", j:"testval3" } } );
+ use mycluster_mydb_regression_slot;
+ db.testing_multi_pkey.updateOne( { a: NumberInt("1"), b: NumberInt("1"), c: NumberInt("2") }, { $set:  { a: NumberInt("14"), b: NumberInt("1"), c: NumberInt("14"), d: NumberLong("33"), e: NumberInt("555"), f:777.8889, g: NumberDecimal("3.33"), h:"testval1            ", i:"testval2", j:"testval3" } } );
+ use mycluster_mydb_regression_slot;
+ db.testing_multi_pkey.updateOne( { a: NumberInt("14"), b: NumberInt("1"), c: NumberInt("14") }, { $set:  { a: NumberInt("15"), b: NumberInt("15"), c: NumberInt("15"), d: NumberLong("33"), e: NumberInt("555"), f:777.8889, g: NumberDecimal("3.33"), h:"testval1            ", i:"testval2", j:"testval3" } } );
+ use mycluster_mydb_regression_slot;
+ db.testing_no_pkey.updateOne({ selector: "null" }, { $set:  { a: NumberInt("1"), b: NumberInt("1"), c: NumberInt("2"), d: NumberLong("33"), e: NumberInt("555"), f:666.7778, g: NumberDecimal("3.33"), h:"changed             ", i:"testval2", j:"testval3" } } );
+ use mycluster_mydb_regression_slot;
+ db.testing_unique.updateOne({ selector: "null" }, { $set:  { a: NumberInt("1"), b: NumberInt("1"), c: NumberInt("2"), d: NumberLong("33"), e: NumberInt("555"), f:666.7778, g: NumberDecimal("3.33"), h:"changed             ", i:"testval2", j:"testval3" } } );
+ use mycluster_mydb_regression_slot;
+ db.testing_unique.updateOne({ selector: "null" }, { $set:  { a: NumberInt("1"), b: NumberInt("1"), c: NumberInt("2"), d: NumberLong("33"), e: NumberInt("555"), f:888.8889, g: NumberDecimal("3.33"), h:"changed             ", i:"testval2", j:"testval3" } } );
+ use mycluster_mydb_regression_slot;
+ db.testing_unique.updateOne({ selector: "null" }, { $set:  { a: NumberInt("1"), b: NumberInt("1"), c: NumberInt("2"), d: NumberLong("33"), e: NumberInt("555"), f:888.8889, g: NumberDecimal("6.66"), h:"changed             ", i:"testval2", j:"testval3" } } );
+(26 rows)
+
+DROP TABLE testing_unique;
+DROP TABLE testing_no_pkey;
+DROP TABLE testing_multi_pkey;
+DROP TABLE testing_one_pkey;
+SELECT 'end' FROM pg_drop_replication_slot('regression_slot');
+ ?column? 
+----------
+ end
+(1 row)
+
diff --git a/contrib/wal2mongo/expected/specval.out b/contrib/wal2mongo/expected/specval.out
new file mode 100644
index 0000000000..b14a659750
--- /dev/null
+++ b/contrib/wal2mongo/expected/specval.out
@@ -0,0 +1,42 @@
+\set VERBOSITY terse
+-- predictability
+SET synchronous_commit = on;
+SELECT 'init' FROM pg_create_logical_replication_slot('regression_slot', 'wal2mongo');
+ ?column? 
+----------
+ init
+(1 row)
+
+CREATE TABLE testing (
+	a serial PRIMARY KEY,
+	b varchar(80),
+	c bool,
+	d real
+);
+BEGIN;
+INSERT INTO testing (b, c, d) VALUES( E'valid: '' " \\ / \d \f \r \t \u447F \u967F invalid: \\g \\k end', FALSE, 123.456);
+INSERT INTO testing (b, c, d) VALUES('aaa', 't', '+inf');
+INSERT INTO testing (b, c, d) VALUES('aaa', 'f', 'nan');
+INSERT INTO testing (b, c, d) VALUES('null', NULL, '-inf');
+COMMIT;
+-- get changes
+SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'regress', 'true', 'skip_empty_xacts', 'true');
+                                                                data                                                                 
+-------------------------------------------------------------------------------------------------------------------------------------
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a: NumberInt("1"), b:"valid: '' " \ / d \x0C \r          䑿 陿 invalid: \g \k end", c:false, d:123.456 } );
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a: NumberInt("2"), b:"aaa", c:true, d:Infinity } );
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a: NumberInt("3"), b:"aaa", c:false, d:NaN } );
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a: NumberInt("4"), b:"null", d:-Infinity } );
+(8 rows)
+
+DROP TABLE testing;
+SELECT 'end' FROM pg_drop_replication_slot('regression_slot');
+ ?column? 
+----------
+ end
+(1 row)
+
diff --git a/contrib/wal2mongo/expected/specval_1.out b/contrib/wal2mongo/expected/specval_1.out
new file mode 100755
index 0000000000..e2a07ecc02
--- /dev/null
+++ b/contrib/wal2mongo/expected/specval_1.out
@@ -0,0 +1,38 @@
+\set VERBOSITY terse
+-- predictability
+SET synchronous_commit = on;
+SELECT 'init' FROM pg_create_logical_replication_slot('regression_slot', 'wal2mongo');
+ ?column? 
+----------
+ init
+(1 row)
+
+CREATE TABLE testing (
+	a serial PRIMARY KEY,
+	b varchar(80),
+	c bool,
+	d real
+);
+BEGIN;
+INSERT INTO testing (b, c, d) VALUES( E'valid: '' " \\ / \d \f \r \t \u447F \u967F invalid: \\g \\k end', FALSE, 123.456);
+ERROR:  Unicode escape values cannot be used for code point values above 007F when the server encoding is not UTF8 at or near "E'valid: '' " \\ / \d \f \r \t \u447F" at character 39
+INSERT INTO testing (b, c, d) VALUES('aaa', 't', '+inf');
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
+INSERT INTO testing (b, c, d) VALUES('aaa', 'f', 'nan');
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
+INSERT INTO testing (b, c, d) VALUES('null', NULL, '-inf');
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
+COMMIT;
+-- get changes
+SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'regress', 'true', 'skip_empty_xacts', 'true');
+ data 
+------
+(0 rows)
+
+DROP TABLE testing;
+SELECT 'end' FROM pg_drop_replication_slot('regression_slot');
+ ?column? 
+----------
+ end
+(1 row)
+
diff --git a/contrib/wal2mongo/expected/string.out b/contrib/wal2mongo/expected/string.out
new file mode 100644
index 0000000000..d60c308f5d
--- /dev/null
+++ b/contrib/wal2mongo/expected/string.out
@@ -0,0 +1,134 @@
+\set VERBOSITY terse
+-- predictability
+SET synchronous_commit = on;
+SELECT 'init' FROM pg_create_logical_replication_slot('regression_slot', 'wal2mongo');
+ ?column? 
+----------
+ init
+(1 row)
+
+-- network address
+CREATE TABLE tbl_net (id serial PRIMARY KEY, a inet, b cidr, c macaddr, d macaddr8);
+-- ipv4 in different format
+INSERT INTO tbl_net(a,b,c,d) VALUES('192.168.100.128/25'::inet, '192.168.100.128/25'::cidr, '08:00:2b:01:02:03'::macaddr, '08:00:2b:01:02:03:04:05'::macaddr8);
+INSERT INTO tbl_net(a,b,c,d) VALUES('192.168.0.1/24'::inet, '192.168/24'::cidr, '08-00-2b-01-02-03'::macaddr, '08-00-2b-01-02-03-04-05'::macaddr8);
+INSERT INTO tbl_net(a,b,c,d) VALUES('192.168.0.0/16'::inet, '192.168'::cidr, '08002b:010203'::macaddr, '08002b:0102030405'::macaddr8);
+INSERT INTO tbl_net(a,b,c,d) VALUES('10.0.0.1/8'::inet, '10'::cidr, '08002b-010203'::macaddr, '08002b-0102030405'::macaddr8);
+INSERT INTO tbl_net(a,b,c,d) VALUES('10.1.2.3/32'::inet, '10.1.2.3/32'::cidr, '0800.2b01.0203'::macaddr, '0800.2b01.0203.0405'::macaddr8);
+INSERT INTO tbl_net(a,b,c,d) VALUES('2001:4f8:3:ba::/64'::inet, '2001:4f8:3:ba::/64'::cidr, '0800-2b01-0203'::macaddr, '0800-2b01-0203-0405'::macaddr8);
+-- ipv6 and mac in lower case
+INSERT INTO tbl_net(a,b,c,d) VALUES('2001:4f8:3:ba:2e0:81ff:fe22:d1f1/128'::inet, '2001:4f8:3:ba:2e0:81ff:fe22:d1f1/128'::cidr, '08002b010203'::macaddr, '08002b01:02030405'::macaddr8);
+-- ipv6 and mac in upper case
+INSERT INTO tbl_net(a,b,c,d) VALUES('2001:4F8:3:BA:2E0:81FF:FE22:D1F1/128'::inet, '2001:4F8:3:BA:2E0:81FF:FE22:D1F1/128'::cidr, '08002B010203'::macaddr, '08002B0102030405'::macaddr8);
+UPDATE tbl_net SET a='10.1.2.3/32'::inet, b='10.1.2.3/32'::cidr, c='0800-2b01-0203'::macaddr, d='0800-2b01-0203-0405'::macaddr8 WHERE id=1;
+DELETE FROM tbl_net WHERE id = 1;
+TRUNCATE TABLE tbl_net;
+-- peek changes
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'regress', 'true');
+                                                                                        data                                                                                         
+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+ use mycluster_mydb_regression_slot;
+ db.tbl_net.insertOne( { id: NumberInt("1"), a:"192.168.100.128/25", b:"192.168.100.128/25", c:"08:00:2b:01:02:03", d:"08:00:2b:01:02:03:04:05" } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_net.insertOne( { id: NumberInt("2"), a:"192.168.0.1/24", b:"192.168.0.0/24", c:"08:00:2b:01:02:03", d:"08:00:2b:01:02:03:04:05" } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_net.insertOne( { id: NumberInt("3"), a:"192.168.0.0/16", b:"192.168.0.0/24", c:"08:00:2b:01:02:03", d:"08:00:2b:01:02:03:04:05" } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_net.insertOne( { id: NumberInt("4"), a:"10.0.0.1/8", b:"10.0.0.0/8", c:"08:00:2b:01:02:03", d:"08:00:2b:01:02:03:04:05" } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_net.insertOne( { id: NumberInt("5"), a:"10.1.2.3", b:"10.1.2.3/32", c:"08:00:2b:01:02:03", d:"08:00:2b:01:02:03:04:05" } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_net.insertOne( { id: NumberInt("6"), a:"2001:4f8:3:ba::/64", b:"2001:4f8:3:ba::/64", c:"08:00:2b:01:02:03", d:"08:00:2b:01:02:03:04:05" } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_net.insertOne( { id: NumberInt("7"), a:"2001:4f8:3:ba:2e0:81ff:fe22:d1f1", b:"2001:4f8:3:ba:2e0:81ff:fe22:d1f1/128", c:"08:00:2b:01:02:03", d:"08:00:2b:01:02:03:04:05" } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_net.insertOne( { id: NumberInt("8"), a:"2001:4f8:3:ba:2e0:81ff:fe22:d1f1", b:"2001:4f8:3:ba:2e0:81ff:fe22:d1f1/128", c:"08:00:2b:01:02:03", d:"08:00:2b:01:02:03:04:05" } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_net.updateOne( { id: NumberInt("1") }, { $set:  { id: NumberInt("1"), a:"10.1.2.3", b:"10.1.2.3/32", c:"08:00:2b:01:02:03", d:"08:00:2b:01:02:03:04:05" } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_net.deleteOne( { id: NumberInt("1") } );
+(20 rows)
+
+-- get changes
+SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'regress', 'true');
+                                                                                        data                                                                                         
+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+ use mycluster_mydb_regression_slot;
+ db.tbl_net.insertOne( { id: NumberInt("1"), a:"192.168.100.128/25", b:"192.168.100.128/25", c:"08:00:2b:01:02:03", d:"08:00:2b:01:02:03:04:05" } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_net.insertOne( { id: NumberInt("2"), a:"192.168.0.1/24", b:"192.168.0.0/24", c:"08:00:2b:01:02:03", d:"08:00:2b:01:02:03:04:05" } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_net.insertOne( { id: NumberInt("3"), a:"192.168.0.0/16", b:"192.168.0.0/24", c:"08:00:2b:01:02:03", d:"08:00:2b:01:02:03:04:05" } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_net.insertOne( { id: NumberInt("4"), a:"10.0.0.1/8", b:"10.0.0.0/8", c:"08:00:2b:01:02:03", d:"08:00:2b:01:02:03:04:05" } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_net.insertOne( { id: NumberInt("5"), a:"10.1.2.3", b:"10.1.2.3/32", c:"08:00:2b:01:02:03", d:"08:00:2b:01:02:03:04:05" } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_net.insertOne( { id: NumberInt("6"), a:"2001:4f8:3:ba::/64", b:"2001:4f8:3:ba::/64", c:"08:00:2b:01:02:03", d:"08:00:2b:01:02:03:04:05" } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_net.insertOne( { id: NumberInt("7"), a:"2001:4f8:3:ba:2e0:81ff:fe22:d1f1", b:"2001:4f8:3:ba:2e0:81ff:fe22:d1f1/128", c:"08:00:2b:01:02:03", d:"08:00:2b:01:02:03:04:05" } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_net.insertOne( { id: NumberInt("8"), a:"2001:4f8:3:ba:2e0:81ff:fe22:d1f1", b:"2001:4f8:3:ba:2e0:81ff:fe22:d1f1/128", c:"08:00:2b:01:02:03", d:"08:00:2b:01:02:03:04:05" } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_net.updateOne( { id: NumberInt("1") }, { $set:  { id: NumberInt("1"), a:"10.1.2.3", b:"10.1.2.3/32", c:"08:00:2b:01:02:03", d:"08:00:2b:01:02:03:04:05" } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_net.deleteOne( { id: NumberInt("1") } );
+(20 rows)
+
+-- drop table
+DROP TABLE tbl_net;
+-- geo data
+CREATE TABLE tbl_geo (id serial PRIMARY KEY, a point, b line, c lseg, d box, e path, f path, g polygon, h circle);
+ALTER TABLE tbl_geo REPLICA IDENTITY FULL;
+-- geo different data types
+INSERT INTO tbl_geo(a,b,c,d,e,f,g,h) VALUES('(1,1)'::point, '[(1,1),(2,2)]'::line, '[(3,3), (4,4)]'::lseg, '((1,1),(2,2))'::box, '[(1,1),(2,2),(3,3)]'::path, '((1,1),(2,2),(3,3))'::path, '((1,1),(2,2),(3,3),(4,4))'::polygon, '<(1,1),5>'::circle);
+UPDATE tbl_geo SET a='11,11'::point, b='((11,11),(12,12))'::line, c='((13,13), (14,14))'::lseg, d='(11,11),(12,12)'::box, e='(11,11),(12,12),(13,13)'::path, f='(11,11,12,12,13,13)'::path, g='(11,11),(12,12),(13,13),(14,14)'::polygon, h='((11,11),15)'::circle WHERE id=1;
+INSERT INTO tbl_geo(a,b,c,d,e,f,g,h) VALUES('(1,1)'::point, '(1,1),(2,2)'::line, '(3,3), (4,4)'::lseg, '1,1,2,2'::box, '1,1,2,2,3,3'::path, '1,1,2,2,3,3'::path, '(1,1,2,2,3,3,4,4)'::polygon, '1,1,5'::circle);
+UPDATE tbl_geo SET a='21,21'::point, b='21,21,22,22'::line, c='23,23, 24,24'::lseg, d='21,21,22,22'::box, e='(21,21,22,22,23,23)'::path, f='21,21,22,22,23,23'::path, g='21,21,22,22,23,23,24,24'::polygon, h='21,21,25'::circle WHERE id=2;
+DELETE FROM tbl_geo WHERE id = 1;
+DELETE FROM tbl_geo WHERE id = 2;
+TRUNCATE TABLE tbl_geo;
+-- peek changes 
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'regress', 'true');
+                                                                                                                                       data                                                                                                                                       
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+ use mycluster_mydb_regression_slot;
+ db.tbl_geo.insertOne( { id: NumberInt("1"), a:"(1,1)", b:"{1,-1,0}", c:"[(3,3),(4,4)]", d:"(2,2),(1,1)", e:"[(1,1),(2,2),(3,3)]", f:"((1,1),(2,2),(3,3))", g:"((1,1),(2,2),(3,3),(4,4))", h:"<(1,1),5>" } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_geo.updateOne( { id: NumberInt("1") }, { $set:  { id: NumberInt("1"), a:"(11,11)", b:"{1,-1,0}", c:"[(13,13),(14,14)]", d:"(12,12),(11,11)", e:"((11,11),(12,12),(13,13))", f:"((11,11),(12,12),(13,13))", g:"((11,11),(12,12),(13,13),(14,14))", h:"<(11,11),15>" } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_geo.insertOne( { id: NumberInt("2"), a:"(1,1)", b:"{1,-1,0}", c:"[(3,3),(4,4)]", d:"(2,2),(1,1)", e:"((1,1),(2,2),(3,3))", f:"((1,1),(2,2),(3,3))", g:"((1,1),(2,2),(3,3),(4,4))", h:"<(1,1),5>" } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_geo.updateOne( { id: NumberInt("2") }, { $set:  { id: NumberInt("2"), a:"(21,21)", b:"{1,-1,0}", c:"[(23,23),(24,24)]", d:"(22,22),(21,21)", e:"((21,21),(22,22),(23,23))", f:"((21,21),(22,22),(23,23))", g:"((21,21),(22,22),(23,23),(24,24))", h:"<(21,21),25>" } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_geo.deleteOne( { id: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_geo.deleteOne( { id: NumberInt("2") } );
+(12 rows)
+
+-- get changes
+SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'regress', 'true');
+                                                                                                                                       data                                                                                                                                       
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+ use mycluster_mydb_regression_slot;
+ db.tbl_geo.insertOne( { id: NumberInt("1"), a:"(1,1)", b:"{1,-1,0}", c:"[(3,3),(4,4)]", d:"(2,2),(1,1)", e:"[(1,1),(2,2),(3,3)]", f:"((1,1),(2,2),(3,3))", g:"((1,1),(2,2),(3,3),(4,4))", h:"<(1,1),5>" } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_geo.updateOne( { id: NumberInt("1") }, { $set:  { id: NumberInt("1"), a:"(11,11)", b:"{1,-1,0}", c:"[(13,13),(14,14)]", d:"(12,12),(11,11)", e:"((11,11),(12,12),(13,13))", f:"((11,11),(12,12),(13,13))", g:"((11,11),(12,12),(13,13),(14,14))", h:"<(11,11),15>" } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_geo.insertOne( { id: NumberInt("2"), a:"(1,1)", b:"{1,-1,0}", c:"[(3,3),(4,4)]", d:"(2,2),(1,1)", e:"((1,1),(2,2),(3,3))", f:"((1,1),(2,2),(3,3))", g:"((1,1),(2,2),(3,3),(4,4))", h:"<(1,1),5>" } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_geo.updateOne( { id: NumberInt("2") }, { $set:  { id: NumberInt("2"), a:"(21,21)", b:"{1,-1,0}", c:"[(23,23),(24,24)]", d:"(22,22),(21,21)", e:"((21,21),(22,22),(23,23))", f:"((21,21),(22,22),(23,23))", g:"((21,21),(22,22),(23,23),(24,24))", h:"<(21,21),25>" } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_geo.deleteOne( { id: NumberInt("1") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_geo.deleteOne( { id: NumberInt("2") } );
+(12 rows)
+
+-- drop table
+DROP TABLE tbl_geo;
+SELECT 'end' FROM pg_drop_replication_slot('regression_slot');
+ ?column? 
+----------
+ end
+(1 row)
+
diff --git a/contrib/wal2mongo/expected/timestamptz.out b/contrib/wal2mongo/expected/timestamptz.out
new file mode 100644
index 0000000000..3b8134c1d2
--- /dev/null
+++ b/contrib/wal2mongo/expected/timestamptz.out
@@ -0,0 +1,47 @@
+\set VERBOSITY terse
+-- predictability
+SET synchronous_commit = on;
+SELECT 'init' FROM pg_create_logical_replication_slot('regression_slot', 'wal2mongo');
+ ?column? 
+----------
+ init
+(1 row)
+
+-- timestamptz
+CREATE TABLE tbl_tstz ( id serial PRIMARY KEY, tstz TIMESTAMPTZ NOT NULL );
+INSERT INTO tbl_tstz (tstz) VALUES('2020-03-24 16:00:30-07') ;
+UPDATE tbl_tstz SET tstz = '2020-03-24 16:30:00-07' WHERE id=1;
+DELETE FROM tbl_tstz WHERE id = 1;
+TRUNCATE TABLE tbl_tstz;
+-- peek changes according to action configuration
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'regress', 'true');
+                                                              data                                                               
+---------------------------------------------------------------------------------------------------------------------------------
+ use mycluster_mydb_regression_slot;
+ db.tbl_tstz.insertOne( { id: NumberInt("1"), tstz: ISODate("2020-03-24T16:00:30-07:00") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_tstz.updateOne( { id: NumberInt("1") }, { $set:  { id: NumberInt("1"), tstz: ISODate("2020-03-24T16:30:00-07:00") } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_tstz.deleteOne( { id: NumberInt("1") } );
+(6 rows)
+
+-- get changes according to action configuration
+SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'regress', 'true');
+                                                              data                                                               
+---------------------------------------------------------------------------------------------------------------------------------
+ use mycluster_mydb_regression_slot;
+ db.tbl_tstz.insertOne( { id: NumberInt("1"), tstz: ISODate("2020-03-24T16:00:30-07:00") } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_tstz.updateOne( { id: NumberInt("1") }, { $set:  { id: NumberInt("1"), tstz: ISODate("2020-03-24T16:30:00-07:00") } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_tstz.deleteOne( { id: NumberInt("1") } );
+(6 rows)
+
+-- drop tables
+DROP TABLE tbl_tstz;
+SELECT 'end' FROM pg_drop_replication_slot('regression_slot');
+ ?column? 
+----------
+ end
+(1 row)
+
diff --git a/contrib/wal2mongo/expected/transaction.out b/contrib/wal2mongo/expected/transaction.out
new file mode 100644
index 0000000000..fef86d8a73
--- /dev/null
+++ b/contrib/wal2mongo/expected/transaction.out
@@ -0,0 +1,95 @@
+\set VERBOSITY terse
+-- predictability
+SET synchronous_commit = on;
+SELECT 'init' FROM pg_create_logical_replication_slot('regression_slot', 'wal2mongo');
+ ?column? 
+----------
+ init
+(1 row)
+
+-- actions
+CREATE TABLE testing (a varchar(30) primary key);
+INSERT INTO testing (a) VALUES('cary');
+INSERT INTO testing (a) VALUES('john');
+INSERT INTO testing (a) VALUES('peter');
+-- define a transaction containing sub transactions
+BEGIN;
+INSERT INTO testing (a) VALUES('david');
+SAVEPOINT p1;
+INSERT INTO testing (a) VALUES('grant');
+SAVEPOINT p2;
+INSERT INTO testing (a) VALUES('mike');
+SAVEPOINT p3;
+INSERT INTO testing (a) VALUES('allen');
+SAVEPOINT p4;
+INSERT INTO testing (a) VALUES('dan');
+ROLLBACK TO SAVEPOINT p3;
+RELEASE SAVEPOINT p1;
+INSERT INTO testing (a) VALUES('cheese');
+COMMIT;
+-- peek and get changes with and without transaction mode
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'use_transaction', 'true', 'regress', 'true');
+                          data                           
+---------------------------------------------------------
+ session0regression_slot = db.getMongo().startSession();
+ session0regression_slot.startTransaction();
+ session0regression_slot.commitTransaction();
+ session0regression_slot.endSession();
+ session0regression_slot = db.getMongo().startSession();
+ session0regression_slot.startTransaction();
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a:"cary" } );
+ session0regression_slot.commitTransaction();
+ session0regression_slot.endSession();
+ session0regression_slot = db.getMongo().startSession();
+ session0regression_slot.startTransaction();
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a:"john" } );
+ session0regression_slot.commitTransaction();
+ session0regression_slot.endSession();
+ session0regression_slot = db.getMongo().startSession();
+ session0regression_slot.startTransaction();
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a:"peter" } );
+ session0regression_slot.commitTransaction();
+ session0regression_slot.endSession();
+ session0regression_slot = db.getMongo().startSession();
+ session0regression_slot.startTransaction();
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a:"david" } );
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a:"grant" } );
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a:"mike" } );
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a:"cheese" } );
+ session0regression_slot.commitTransaction();
+ session0regression_slot.endSession();
+(34 rows)
+
+SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'use_transaction', 'false', 'regress', 'true', 'skip_empty_xacts', 'false');
+                  data                   
+-----------------------------------------
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a:"cary" } );
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a:"john" } );
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a:"peter" } );
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a:"david" } );
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a:"grant" } );
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a:"mike" } );
+ use mycluster_mydb_regression_slot;
+ db.testing.insertOne( { a:"cheese" } );
+(14 rows)
+
+DROP TABLE testing;
+SELECT 'end' FROM pg_drop_replication_slot('regression_slot');
+ ?column? 
+----------
+ end
+(1 row)
+
diff --git a/contrib/wal2mongo/expected/xml.out b/contrib/wal2mongo/expected/xml.out
new file mode 100644
index 0000000000..74bba8561c
--- /dev/null
+++ b/contrib/wal2mongo/expected/xml.out
@@ -0,0 +1,137 @@
+\set VERBOSITY terse
+-- predictability
+SET synchronous_commit = on;
+SELECT 'init' FROM pg_create_logical_replication_slot('regression_slot', 'wal2mongo');
+ ?column? 
+----------
+ init
+(1 row)
+
+-- xml data
+CREATE TABLE tbl_xml (id serial primary key, a xml);
+-- insert data simple SQL way
+INSERT INTO tbl_xml(a) VALUES('<foo> xml-data </foo>'::xml);
+-- using XMLPARSE and DOCUMENT syntaxes
+INSERT INTO tbl_xml(a) VALUES(XMLPARSE (DOCUMENT'<foo> xml-data </foo>'));
+-- xpath example simple SQL way
+INSERT INTO tbl_xml(a) VALUES('
+<dept
+    xmlns:smpl="http://example.com" smpl:did="DPT011-IT">
+    <name>IT</name>
+    <persons>
+        <person smpl:pid="111">
+            <name>John Smith</name>
+            <age>24</age>
+        </person>
+        <person smpl:pid="112">
+            <name>Michael Black</name>
+            <age>28</age>
+        </person>
+    </persons>
+</dept>'::xml);
+-- xpath example in minify way
+INSERT INTO tbl_xml(a) VALUES('<dept xmlns:smpl="http://example.com" smpl:did="DPT011-IT"><name>IT</name><persons><person smpl:pid="111"><name>John Smith</name><age>24</age></person><person smpl:pid="112"><name>Michael Black</name><age>28</age></person></persons></dept>'::xml);
+-- xpath example using XMLPARSE and DOCUMENT
+INSERT INTO tbl_xml(a) VALUES(XMLPARSE (DOCUMENT'
+<dept
+    xmlns:smpl="http://example.com" smpl:did="DPT011-IT">
+    <name>IT</name>
+    <persons>
+        <person smpl:pid="111">
+            <name>John Smith</name>
+            <age>24</age>
+        </person>
+        <person smpl:pid="112">
+            <name>Michael Black</name>
+            <age>28</age>
+        </person>
+    </persons>
+</dept>'));
+-- update using simple SQL way
+UPDATE tbl_xml SET a = '                                                      
+<dept                                                                           
+    xmlns:smpl="http://example.com" smpl:did="DPT011-IT">                       
+    <name>IT</name>                                                             
+    <persons>                                                                   
+        <person smpl:pid="111">                                                 
+            <name>John Smith</name>                                             
+            <age>24</age>                                                       
+        </person>                                                               
+        <person smpl:pid="112">                                                 
+            <name>Michael Black</name>                                          
+            <age>28</age>                                                       
+        </person>                                                               
+    </persons>                                                                  
+</dept>'::xml WHERE id=1;
+-- update using XMLPARSE and DOCUMENT syntaxes
+UPDATE tbl_xml SET a = 
+XMLPARSE (DOCUMENT'                               
+<dept                                                                           
+    xmlns:smpl="http://example.com" smpl:did="DPT011-IT">                       
+    <name>IT</name>                                                             
+    <persons>                                                                   
+        <person smpl:pid="111">                                                 
+            <name>John Smith</name>                                             
+            <age>24</age>                                                       
+        </person>                                                               
+        <person smpl:pid="112">                                                 
+            <name>Michael Black</name>                                          
+            <age>28</age>                                                       
+        </person>                                                               
+    </persons>                                                                  
+</dept>') WHERE id=2;
+-- delete
+DELETE FROM tbl_xml WHERE id = 1;
+TRUNCATE TABLE tbl_xml;
+-- peek changes 
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'regress', 'true');
+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     data                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+ use mycluster_mydb_regression_slot;
+ db.tbl_xml.insertOne( { id: NumberInt("1"), a:"<foo> xml-data </foo>" } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_xml.insertOne( { id: NumberInt("2"), a:"<foo> xml-data </foo>" } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_xml.insertOne( { id: NumberInt("3"), a:"<dept    xmlns:smpl=\"http://example.com\" smpl:did=\"DPT011-IT\">    <name>IT</name>    <persons>        <person smpl:pid=\"111\">            <name>John Smith</name>            <age>24</age>        </person>        <person smpl:pid=\"112\">            <name>Michael Black</name>            <age>28</age>        </person>    </persons></dept>" } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_xml.insertOne( { id: NumberInt("4"), a:"<dept xmlns:smpl=\"http://example.com\" smpl:did=\"DPT011-IT\"><name>IT</name><persons><person smpl:pid=\"111\"><name>John Smith</name><age>24</age></person><person smpl:pid=\"112\"><name>Michael Black</name><age>28</age></person></persons></dept>" } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_xml.insertOne( { id: NumberInt("5"), a:"<dept    xmlns:smpl=\"http://example.com\" smpl:did=\"DPT011-IT\">    <name>IT</name>    <persons>        <person smpl:pid=\"111\">            <name>John Smith</name>            <age>24</age>        </person>        <person smpl:pid=\"112\">            <name>Michael Black</name>            <age>28</age>        </person>    </persons></dept>" } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_xml.updateOne( { id: NumberInt("1") }, { $set:  { id: NumberInt("1"), a:"                                                      <dept                                                                               xmlns:smpl=\"http://example.com\" smpl:did=\"DPT011-IT\">                           <name>IT</name>                                                                 <persons>                                                                           <person smpl:pid=\"111\">                                                             <name>John Smith</name>                                                         <age>24</age>                                                               </person>                                                                       <person smpl:pid=\"112\">                                                             <name>Michael Black</name>                                                      <age>28</age>                                                               </person>                                                                   </persons>                                                                  </dept>" } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_xml.updateOne( { id: NumberInt("2") }, { $set:  { id: NumberInt("2"), a:"                               <dept                                                                               xmlns:smpl=\"http://example.com\" smpl:did=\"DPT011-IT\">                           <name>IT</name>                                                                 <persons>                                                                           <person smpl:pid=\"111\">                                                             <name>John Smith</name>                                                         <age>24</age>                                                               </person>                                                                       <person smpl:pid=\"112\">                                                             <name>Michael Black</name>                                                      <age>28</age>                                                               </person>                                                                   </persons>                                                                  </dept>" } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_xml.deleteOne( { id: NumberInt("1") } );
+(16 rows)
+
+-- get changes
+SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'regress', 'true');
+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     data                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+ use mycluster_mydb_regression_slot;
+ db.tbl_xml.insertOne( { id: NumberInt("1"), a:"<foo> xml-data </foo>" } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_xml.insertOne( { id: NumberInt("2"), a:"<foo> xml-data </foo>" } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_xml.insertOne( { id: NumberInt("3"), a:"<dept    xmlns:smpl=\"http://example.com\" smpl:did=\"DPT011-IT\">    <name>IT</name>    <persons>        <person smpl:pid=\"111\">            <name>John Smith</name>            <age>24</age>        </person>        <person smpl:pid=\"112\">            <name>Michael Black</name>            <age>28</age>        </person>    </persons></dept>" } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_xml.insertOne( { id: NumberInt("4"), a:"<dept xmlns:smpl=\"http://example.com\" smpl:did=\"DPT011-IT\"><name>IT</name><persons><person smpl:pid=\"111\"><name>John Smith</name><age>24</age></person><person smpl:pid=\"112\"><name>Michael Black</name><age>28</age></person></persons></dept>" } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_xml.insertOne( { id: NumberInt("5"), a:"<dept    xmlns:smpl=\"http://example.com\" smpl:did=\"DPT011-IT\">    <name>IT</name>    <persons>        <person smpl:pid=\"111\">            <name>John Smith</name>            <age>24</age>        </person>        <person smpl:pid=\"112\">            <name>Michael Black</name>            <age>28</age>        </person>    </persons></dept>" } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_xml.updateOne( { id: NumberInt("1") }, { $set:  { id: NumberInt("1"), a:"                                                      <dept                                                                               xmlns:smpl=\"http://example.com\" smpl:did=\"DPT011-IT\">                           <name>IT</name>                                                                 <persons>                                                                           <person smpl:pid=\"111\">                                                             <name>John Smith</name>                                                         <age>24</age>                                                               </person>                                                                       <person smpl:pid=\"112\">                                                             <name>Michael Black</name>                                                      <age>28</age>                                                               </person>                                                                   </persons>                                                                  </dept>" } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_xml.updateOne( { id: NumberInt("2") }, { $set:  { id: NumberInt("2"), a:"                               <dept                                                                               xmlns:smpl=\"http://example.com\" smpl:did=\"DPT011-IT\">                           <name>IT</name>                                                                 <persons>                                                                           <person smpl:pid=\"111\">                                                             <name>John Smith</name>                                                         <age>24</age>                                                               </person>                                                                       <person smpl:pid=\"112\">                                                             <name>Michael Black</name>                                                      <age>28</age>                                                               </person>                                                                   </persons>                                                                  </dept>" } } );
+ use mycluster_mydb_regression_slot;
+ db.tbl_xml.deleteOne( { id: NumberInt("1") } );
+(16 rows)
+
+-- drop table
+DROP TABLE tbl_xml;
+SELECT 'end' FROM pg_drop_replication_slot('regression_slot');
+ ?column? 
+----------
+ end
+(1 row)
+
diff --git a/contrib/wal2mongo/expected/xml_1.out b/contrib/wal2mongo/expected/xml_1.out
new file mode 100644
index 0000000000..b744c3e0d9
--- /dev/null
+++ b/contrib/wal2mongo/expected/xml_1.out
@@ -0,0 +1,111 @@
+\set VERBOSITY terse
+-- predictability
+SET synchronous_commit = on;
+SELECT 'init' FROM pg_create_logical_replication_slot('regression_slot', 'wal2mongo');
+ ?column? 
+----------
+ init
+(1 row)
+
+-- xml data
+CREATE TABLE tbl_xml (id serial primary key, a xml);
+-- insert data simple SQL way
+INSERT INTO tbl_xml(a) VALUES('<foo> xml-data </foo>'::xml);
+ERROR:  unsupported XML feature at character 31
+-- using XMLPARSE and DOCUMENT syntaxes
+INSERT INTO tbl_xml(a) VALUES(XMLPARSE (DOCUMENT'<foo> xml-data </foo>'));
+ERROR:  unsupported XML feature
+-- xpath example simple SQL way
+INSERT INTO tbl_xml(a) VALUES('
+<dept
+    xmlns:smpl="http://example.com" smpl:did="DPT011-IT">
+    <name>IT</name>
+    <persons>
+        <person smpl:pid="111">
+            <name>John Smith</name>
+            <age>24</age>
+        </person>
+        <person smpl:pid="112">
+            <name>Michael Black</name>
+            <age>28</age>
+        </person>
+    </persons>
+</dept>'::xml);
+ERROR:  unsupported XML feature at character 31
+-- xpath example in minify way
+INSERT INTO tbl_xml(a) VALUES('<dept xmlns:smpl="http://example.com" smpl:did="DPT011-IT"><name>IT</name><persons><person smpl:pid="111"><name>John Smith</name><age>24</age></person><person smpl:pid="112"><name>Michael Black</name><age>28</age></person></persons></dept>'::xml);
+ERROR:  unsupported XML feature at character 31
+-- xpath example using XMLPARSE and DOCUMENT
+INSERT INTO tbl_xml(a) VALUES(XMLPARSE (DOCUMENT'
+<dept
+    xmlns:smpl="http://example.com" smpl:did="DPT011-IT">
+    <name>IT</name>
+    <persons>
+        <person smpl:pid="111">
+            <name>John Smith</name>
+            <age>24</age>
+        </person>
+        <person smpl:pid="112">
+            <name>Michael Black</name>
+            <age>28</age>
+        </person>
+    </persons>
+</dept>'));
+ERROR:  unsupported XML feature
+-- update using simple SQL way
+UPDATE tbl_xml SET a = '                                                      
+<dept                                                                           
+    xmlns:smpl="http://example.com" smpl:did="DPT011-IT">                       
+    <name>IT</name>                                                             
+    <persons>                                                                   
+        <person smpl:pid="111">                                                 
+            <name>John Smith</name>                                             
+            <age>24</age>                                                       
+        </person>                                                               
+        <person smpl:pid="112">                                                 
+            <name>Michael Black</name>                                          
+            <age>28</age>                                                       
+        </person>                                                               
+    </persons>                                                                  
+</dept>'::xml WHERE id=1;
+ERROR:  unsupported XML feature at character 24
+-- update using XMLPARSE and DOCUMENT syntaxes
+UPDATE tbl_xml SET a = 
+XMLPARSE (DOCUMENT'                               
+<dept                                                                           
+    xmlns:smpl="http://example.com" smpl:did="DPT011-IT">                       
+    <name>IT</name>                                                             
+    <persons>                                                                   
+        <person smpl:pid="111">                                                 
+            <name>John Smith</name>                                             
+            <age>24</age>                                                       
+        </person>                                                               
+        <person smpl:pid="112">                                                 
+            <name>Michael Black</name>                                          
+            <age>28</age>                                                       
+        </person>                                                               
+    </persons>                                                                  
+</dept>') WHERE id=2;
+-- delete
+DELETE FROM tbl_xml WHERE id = 1;
+TRUNCATE TABLE tbl_xml;
+-- peek changes 
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'regress', 'true');
+ data 
+------
+(0 rows)
+
+-- get changes
+SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'regress', 'true');
+ data 
+------
+(0 rows)
+
+-- drop table
+DROP TABLE tbl_xml;
+SELECT 'end' FROM pg_drop_replication_slot('regression_slot');
+ ?column? 
+----------
+ end
+(1 row)
+
diff --git a/contrib/wal2mongo/logical.conf b/contrib/wal2mongo/logical.conf
new file mode 100644
index 0000000000..367f706651
--- /dev/null
+++ b/contrib/wal2mongo/logical.conf
@@ -0,0 +1,2 @@
+wal_level = logical
+max_replication_slots = 4
diff --git a/contrib/wal2mongo/sql/actions.sql b/contrib/wal2mongo/sql/actions.sql
new file mode 100644
index 0000000000..d34e27d104
--- /dev/null
+++ b/contrib/wal2mongo/sql/actions.sql
@@ -0,0 +1,35 @@
+\set VERBOSITY terse
+
+-- predictability
+SET synchronous_commit = on;
+
+SELECT 'init' FROM pg_create_logical_replication_slot('regression_slot', 'wal2mongo');
+
+-- actions
+CREATE TABLE testing (a integer primary key);
+INSERT INTO testing (a) VALUES(200);
+UPDATE testing SET a = 500 WHERE a = 200;
+DELETE FROM testing WHERE a = 500;
+TRUNCATE TABLE testing;
+
+-- peek changes according to action configuration
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'actions', 'insert', 'regress', 'true');
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'actions', 'update', 'regress', 'true');
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'actions', 'delete', 'regress', 'true');
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'actions', 'truncate', 'regress', 'true');
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'actions', 'insert, update, delete, truncate', 'regress', 'true');
+
+-- peek changes with default action configuraiton
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'regress', 'true');
+
+-- peek changes with several configuration parameter combinations
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'include_cluster_name', 'true', 'regress', 'true');
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'skip_empty_xacts', 'true', 'regress', 'true');
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'only_local', 'true', 'regress', 'true');
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'use_transaction', 'true', 'regress', 'true');
+
+-- peek changes with invalid actions
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'actions', 'insert, xxx, delete, xxx', 'regress', 'true');
+
+DROP TABLE testing;
+SELECT 'end' FROM pg_drop_replication_slot('regression_slot');
diff --git a/contrib/wal2mongo/sql/array.sql b/contrib/wal2mongo/sql/array.sql
new file mode 100644
index 0000000000..d35b8ee849
--- /dev/null
+++ b/contrib/wal2mongo/sql/array.sql
@@ -0,0 +1,54 @@
+\set VERBOSITY terse
+
+-- predictability
+SET synchronous_commit = on;
+
+SELECT 'init' FROM pg_create_logical_replication_slot('regression_slot', 'wal2mongo');
+
+-- create table with different numeric type
+CREATE TABLE tbl_array(id serial primary key, a bool[], c char[], d name[], e int2[], f int4[], g text[], h varchar[], i int8[], j float4[], k float8[], l timestamptz[], m numeric[], n uuid[] );
+
+-- different data types for array
+INSERT INTO tbl_array (a, c, d, e, f, g, h, i, j, k, l, m, n) VALUES(
+ARRAY[true, false], 
+ARRAY['c'::char,'h'::char], 
+ARRAY['student'::name, 'teacher'::name], 
+ARRAY['123'::int2, '456'::int2],
+ARRAY['123456789'::int4,'987654321'::int4],
+ARRAY['abc'::text, '123'::text],
+ARRAY['ABCD'::varchar, '1234'::varchar],
+ARRAY['112233445566778899'::int8, '998877665544332211'::int8],
+ARRAY['123.456'::float4, '2222.3333'::float4],
+ARRAY['123456.123'::float8, '654321.123'::float8],
+ARRAY['2020-03-30 10:18:40.12-07'::timestamptz, '2020-03-30 20:28:40.12-07'::timestamptz],
+ARRAY['123456789'::numeric, '987654321'::numeric],
+ARRAY['40e6215d-b5c6-4896-987c-f30f3678f608'::uuid, '3f333df6-90a4-4fda-8dd3-9485d27cee36'::uuid]
+);
+UPDATE tbl_array SET
+a=ARRAY[false, true], 
+c=ARRAY['h'::char, 'c'::char], 
+d=ARRAY['teacher'::name, 'student'::name], 
+e=ARRAY['456'::int2, '123'::int2],
+f=ARRAY['987654321'::int4, '123456789'::int4],
+g=ARRAY['123'::text, 'abc'::text],
+h=ARRAY['1234'::varchar, 'ABCD'::varchar],
+i=ARRAY['998877665544332211'::int8, '112233445566778899'::int8],
+j=ARRAY['2222.3333'::float4, '123.456'::float4],
+k=ARRAY['654321.123'::float8, '123456.123'::float8],
+l=ARRAY['2020-03-30 20:28:40.12-07'::timestamptz, '2020-03-30 10:18:40.12-07'::timestamptz],
+m=ARRAY['987654321'::numeric, '123456789'::numeric],
+n=ARRAY['3f333df6-90a4-4fda-8dd3-9485d27cee36'::uuid, '40e6215d-b5c6-4896-987c-f30f3678f608'::uuid]
+WHERE id=1;
+DELETE FROM tbl_array WHERE id = 1;
+TRUNCATE TABLE tbl_array;
+
+
+-- peek changes according to action configuration
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'regress', 'true');
+
+-- get changes according to action configuration
+SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'regress', 'true');
+
+-- drop table
+DROP TABLE tbl_array;
+SELECT 'end' FROM pg_drop_replication_slot('regression_slot');
diff --git a/contrib/wal2mongo/sql/binData.sql b/contrib/wal2mongo/sql/binData.sql
new file mode 100644
index 0000000000..6e5d5ebcfd
--- /dev/null
+++ b/contrib/wal2mongo/sql/binData.sql
@@ -0,0 +1,33 @@
+\set VERBOSITY terse
+
+-- predictability
+SET synchronous_commit = on;
+
+SELECT 'init' FROM pg_create_logical_replication_slot('regression_slot', 'wal2mongo');
+
+-- UUID
+CREATE TABLE tbl_uuid ( id serial PRIMARY KEY, a_uuid UUID NOT NULL );
+INSERT INTO tbl_uuid (a_uuid) VALUES('47deacb1-3ad0-4a0e-8254-9ad3f589c9f3') ;
+UPDATE tbl_uuid SET a_uuid = 'e7d8e462-12cc-49dc-aac2-2b5dccdabeda' WHERE id=1;
+DELETE FROM tbl_uuid WHERE id = 1;
+TRUNCATE TABLE tbl_uuid;
+
+-- BYTEA
+CREATE TABLE tbl_bytea ( id serial PRIMARY KEY, a_bytea bytea NOT NULL );
+ALTER TABLE tbl_bytea REPLICA IDENTITY FULL;
+INSERT INTO tbl_bytea(a_bytea) SELECT 'abc \153\154\155 \052\251\124'::bytea RETURNING a_bytea;
+UPDATE tbl_bytea SET a_bytea = SELECT '\134'::bytea RETURNING a_bytea;
+DELETE FROM tbl_bytea WHERE id = 1;
+TRUNCATE TABLE tbl_bytea;
+
+-- peek changes according to action configuration
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'regress', 'true');
+
+-- get changes according to action configuration
+SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'regress', 'true');
+
+
+-- drop tables
+DROP TABLE tbl_uuid;
+DROP TABLE tbl_bytea;
+SELECT 'end' FROM pg_drop_replication_slot('regression_slot');
diff --git a/contrib/wal2mongo/sql/binary.sql b/contrib/wal2mongo/sql/binary.sql
new file mode 100644
index 0000000000..5496e51f3c
--- /dev/null
+++ b/contrib/wal2mongo/sql/binary.sql
@@ -0,0 +1,14 @@
+-- predictability
+SET synchronous_commit = on;
+
+SELECT 'init' FROM pg_create_logical_replication_slot('regression_slot', 'wal2mongo');
+-- succeeds, textual plugin, textual consumer
+SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'force_binary', '0');
+-- fails, binary plugin, textual consumer
+SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'force_binary', '1');
+-- succeeds, textual plugin, binary consumer
+SELECT data FROM pg_logical_slot_get_binary_changes('regression_slot', NULL, NULL, 'force_binary', '0');
+-- succeeds, binary plugin, binary consumer
+SELECT data FROM pg_logical_slot_get_binary_changes('regression_slot', NULL, NULL, 'force_binary', '1');
+
+SELECT 'init' FROM pg_drop_replication_slot('regression_slot');
diff --git a/contrib/wal2mongo/sql/boolean.sql b/contrib/wal2mongo/sql/boolean.sql
new file mode 100644
index 0000000000..678c06f708
--- /dev/null
+++ b/contrib/wal2mongo/sql/boolean.sql
@@ -0,0 +1,136 @@
+\set VERBOSITY terse
+
+-- predictability
+SET synchronous_commit = on;
+
+SELECT 'init' FROM pg_create_logical_replication_slot('regression_slot', 'wal2mongo');
+
+-- create table with boolean type
+CREATE TABLE tbl_boolean (a integer primary key, b BOOLEAN);
+
+-- true
+INSERT INTO tbl_boolean (a, b) VALUES(1, true);
+UPDATE tbl_boolean SET b = false WHERE a = 1;
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+
+-- 'true'
+INSERT INTO tbl_boolean (a, b) VALUES(1, 'true');
+UPDATE tbl_boolean SET b = 'false' WHERE a = 1;
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+
+-- 't'
+INSERT INTO tbl_boolean (a, b) VALUES(1, 't');
+UPDATE tbl_boolean SET b = 'f' WHERE a = 1;
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+
+-- TRUE
+INSERT INTO tbl_boolean (a, b) VALUES(1, TRUE);
+UPDATE tbl_boolean SET b = TRUE WHERE a = 1;
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+
+-- 'TRUE'
+INSERT INTO tbl_boolean (a, b) VALUES(1, 'TRUE');
+UPDATE tbl_boolean SET b = 'TRUE' WHERE a = 1;
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+
+-- 'T'
+INSERT INTO tbl_boolean (a, b) VALUES(1, 'T');
+UPDATE tbl_boolean SET b = 'T' WHERE a = 1;
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+
+-- 'on'
+INSERT INTO tbl_boolean (a, b) VALUES(1, 'on');
+UPDATE tbl_boolean SET b = 'off' WHERE a = 1;
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+
+-- '1'
+INSERT INTO tbl_boolean (a, b) VALUES(1, '1');
+UPDATE tbl_boolean SET b = '0' WHERE a = 1;
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+
+-- false
+INSERT INTO tbl_boolean (a, b) VALUES(1, false);
+UPDATE tbl_boolean SET b = true WHERE a = 1;
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+
+-- 'false'
+INSERT INTO tbl_boolean (a, b) VALUES(1, 'false');
+UPDATE tbl_boolean SET b = 'true' WHERE a = 1;
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+
+-- 'f'
+INSERT INTO tbl_boolean (a, b) VALUES(1, 'f');
+UPDATE tbl_boolean SET b = 't' WHERE a = 1;
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+
+-- FALSE
+INSERT INTO tbl_boolean (a, b) VALUES(1, FALSE);
+UPDATE tbl_boolean SET b = TRUE WHERE a = 1;
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+
+-- 'FALSE'
+INSERT INTO tbl_boolean (a, b) VALUES(1, 'FALSE');
+UPDATE tbl_boolean SET b = 'TRUE' WHERE a = 1;
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+
+-- 'F'
+INSERT INTO tbl_boolean (a, b) VALUES(1, 'F');
+UPDATE tbl_boolean SET b = 'T' WHERE a = 1;
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+
+-- 'off'
+INSERT INTO tbl_boolean (a, b) VALUES(1, 'off');
+UPDATE tbl_boolean SET b = 'on' WHERE a = 1;
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+
+-- '0'
+INSERT INTO tbl_boolean (a, b) VALUES(1, '0');
+UPDATE tbl_boolean SET b = '1' WHERE a = 1;
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+
+
+-- 'on' exception
+INSERT INTO tbl_boolean (a, b) VALUES(1, on);
+UPDATE tbl_boolean SET b = off WHERE a = 1;
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+
+-- 'enable' exception
+INSERT INTO tbl_boolean (a, b) VALUES(1, 'enable');
+UPDATE tbl_boolean SET b = 'disable' WHERE a = 1;
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+
+-- 'disable' exception
+INSERT INTO tbl_boolean (a, b) VALUES(1, 'disable');
+UPDATE tbl_boolean SET b = 'enable' WHERE a = 1;
+DELETE FROM tbl_boolean WHERE a = 1;
+TRUNCATE TABLE tbl_boolean;
+
+
+-- peek changes according to action configuration
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'regress', 'true');
+
+-- get changes according to action configuration
+SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'regress', 'true');
+
+-- peek changes with invalid actions
+
+DROP TABLE tbl_boolean;
+SELECT 'end' FROM pg_drop_replication_slot('regression_slot');
diff --git a/contrib/wal2mongo/sql/identity.sql b/contrib/wal2mongo/sql/identity.sql
new file mode 100644
index 0000000000..eb11b5df70
--- /dev/null
+++ b/contrib/wal2mongo/sql/identity.sql
@@ -0,0 +1,49 @@
+\set VERBOSITY terse
+
+-- predictability
+SET synchronous_commit = on;
+
+SELECT 'init' FROM pg_create_logical_replication_slot('regression_slot', 'wal2mongo');
+
+-- Replica identity nothing
+CREATE TABLE testing (a varchar(30) primary key, b INT, c INT);
+ALTER TABLE testing REPLICA IDENTITY NOTHING;
+BEGIN;
+INSERT INTO testing VALUES('aaa', 123, 456);
+UPDATE testing set b = 789 where a = 'aaa';
+UPDATE testing set a = 'bbb';
+DELETE from testing where a = 'bbb';
+COMMIT;
+
+-- Replica identity default
+BEGIN;
+ALTER TABLE testing REPLICA IDENTITY DEFAULT;
+INSERT INTO testing VALUES('aaa', 123, 456);
+UPDATE testing set b = 789 where a = 'aaa';
+UPDATE testing set a = 'bbb';
+DELETE from testing where a = 'bbb';
+COMMIT;
+
+-- Replica identity full
+BEGIN;
+ALTER TABLE testing REPLICA IDENTITY FULL;
+INSERT INTO testing VALUES('aaa', 123, 456);
+UPDATE testing set b = 789 where a = 'aaa';
+UPDATE testing set a = 'bbb';
+DELETE from testing where a = 'bbb';
+COMMIT;
+
+-- Replica identity index
+CREATE INDEX idx_test ON testing(b);
+ALTER TABLE testing REPLICA IDENTITY INDEX;
+INSERT INTO testing VALUES('aaa', 123, 456);
+UPDATE testing set b = 789 where a = 'aaa';
+UPDATE testing set a = 'bbb';
+DELETE from testing where a = 'bbb';
+COMMIT;
+
+-- get changes
+SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'regress', 'true', 'skip_empty_xacts', 'true');
+
+DROP TABLE testing;
+SELECT 'end' FROM pg_drop_replication_slot('regression_slot');
diff --git a/contrib/wal2mongo/sql/json.sql b/contrib/wal2mongo/sql/json.sql
new file mode 100755
index 0000000000..dc776ffef3
--- /dev/null
+++ b/contrib/wal2mongo/sql/json.sql
@@ -0,0 +1,74 @@
+\set VERBOSITY terse
+
+-- predictability
+SET synchronous_commit = on;
+
+SELECT 'init' FROM pg_create_logical_replication_slot('regression_slot', 'wal2mongo');
+
+CREATE TABLE testing (a integer primary key, 
+					  j1 json, 
+					  j2 jsonb,
+					  j3 jsonpath,
+					  j4 json[],
+					  j5 jsonb[]);
+
+-- JSON data type
+INSERT INTO testing (a, j1) VALUES(1, '{"customer": "John", "items":{"product":"beer","qty":20}}');
+INSERT INTO testing (a, j1) VALUES(2, '{"customer": "Michael", "items":[{"product":"vodka","qty":5},{"product":"whiskey","qty":10},{"product":"cooler","qty":10}]}');
+INSERT INTO testing (a, j1) VALUES(3, '{"customer": "Joe", "items":{"product":"wine","qty":20}}');
+UPDATE testing set j1='{"customer": "Michael", "items":[{"product":"vodka","qty":5},{"product":"whiskey","qty":10}]}' where a = 3;
+DELETE FROM testing where a = 1;
+
+-- JSONB data type
+INSERT INTO testing (a, j2) VALUES(4, '{"customer": "John", "items":{"product":"beer","qty":20}}');
+INSERT INTO testing (a, j2) VALUES(5, '{"customer": "Michael", "items":[{"product":"vodka","qty":5},{"product":"whiskey","qty":10},{"product":"cooler","qty":10}]}');
+INSERT INTO testing (a, j2) VALUES(6, '{"customer": "Joe", "items":{"product":"wine","qty":20}}');
+UPDATE testing set j2='{"customer": "Michael", "items":[{"product":"vodka","qty":5},{"product":"whiskey","qty":10}]}' where a = 3;
+DELETE FROM testing where a = 1;
+
+-- JSONPATH data type
+INSERT INTO testing (a, j3) VALUES(7, '$.equipment.rings[*] ? (@.track.segments > 1)');
+UPDATE testing set j3 = '$.equipment.rings[*]' where a = 7;
+DELETE from testing where a = 7;
+
+-- JSON[] data type
+INSERT into testing (a, j4) VALUES 
+( 
+	8,
+	array[ 
+		'{"customer": "Cary", "items":{"product":"beer","qty":1000}}',
+		'{"customer": "John", "items":{"product":"beer","qty":2000}}',
+		'{"customer": "David", "items":{"product":"beer","qty":3000}}'
+	]::json[] 
+);
+UPDATE testing set j4 = 
+array[ 
+		'{"customer": "Cary"}',
+		'{"customer": "John"}',
+		'{"customer": "David"}'
+]::json[] where a = 8;
+DELETE FROM testing where a = 8;
+
+-- JSONB[] data type
+INSERT into testing (a, j5) VALUES 
+( 
+	9,
+	array[ 
+		'{"customer": "Cary", "items":{"product":"beer","qty":1000}}',
+		'{"customer": "John", "items":{"product":"beer","qty":2000}}',
+		'{"customer": "David", "items":{"product":"beer","qty":3000}}'
+	]::json[] 
+);
+UPDATE testing set j5 = 
+array[ 
+		'{"customer": "Cary"}',
+		'{"customer": "John"}',
+		'{"customer": "David"}'
+]::json[] where a = 9;
+DELETE FROM testing where a = 9;
+
+-- get the changes
+SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'use_transaction', 'false', 'regress', 'true');
+
+DROP TABLE testing;
+SELECT 'end' FROM pg_drop_replication_slot('regression_slot');
diff --git a/contrib/wal2mongo/sql/numeric.sql b/contrib/wal2mongo/sql/numeric.sql
new file mode 100644
index 0000000000..8cecb57e2d
--- /dev/null
+++ b/contrib/wal2mongo/sql/numeric.sql
@@ -0,0 +1,32 @@
+\set VERBOSITY terse
+
+-- predictability
+SET synchronous_commit = on;
+
+SELECT 'init' FROM pg_create_logical_replication_slot('regression_slot', 'wal2mongo');
+
+-- create table with different numeric type
+CREATE TABLE tbl_int(id serial primary key, a smallint, b integer, c serial, d real, e bigint, f bigserial, g double precision, h decimal, i numeric);
+
+-- minumum values
+INSERT INTO tbl_int values(1, -32768, -2147483648, 1, -0.123456, -9223372036854775808, 1, -1.123456789123456, -1234567890.1234567891, -9876543210.0987654321);
+UPDATE tbl_int SET a=a+1, b=b+1, c=c+1, d=d+1, e=e+1, f=f+1, g=g+1, h=h+1, i=i+1 WHERE id=1;
+DELETE FROM tbl_int WHERE id = 1;
+TRUNCATE TABLE tbl_int;
+
+-- maximum values
+INSERT INTO tbl_int values(1, 32767, 2147483647, 2147483647, 0.123456, 9223372036854775807, 9223372036854775807, 1.123456789123456, 1234567890.1234567891, 9876543210.0987654321);
+UPDATE tbl_int SET a=a-1, b=b-1, c=c-1, d=d-1, e=e-1, f=f-1, g=g-1, h=h-1, i=i-1 WHERE id=1;
+DELETE FROM tbl_int WHERE id = 1;
+TRUNCATE TABLE tbl_int;
+
+
+-- peek changes according to action configuration
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'regress', 'true');
+
+-- get changes according to action configuration
+SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'regress', 'true');
+
+-- drop table
+DROP TABLE tbl_int;
+SELECT 'end' FROM pg_drop_replication_slot('regression_slot');
diff --git a/contrib/wal2mongo/sql/pkey.sql b/contrib/wal2mongo/sql/pkey.sql
new file mode 100644
index 0000000000..d6691cc090
--- /dev/null
+++ b/contrib/wal2mongo/sql/pkey.sql
@@ -0,0 +1,103 @@
+\set VERBOSITY terse
+
+-- predictability
+SET synchronous_commit = on;
+
+SELECT 'init' FROM pg_create_logical_replication_slot('regression_slot', 'wal2mongo');
+
+
+CREATE TABLE testing_one_pkey (
+a smallserial PRIMARY KEY,
+b smallint,
+c int,
+d bigint,
+e int,
+f real,
+g double precision,
+h char(20),
+i varchar(30),
+j text
+);
+
+CREATE TABLE testing_multi_pkey (
+a smallserial,
+b smallint,
+c int,
+d bigint,
+e int,
+f real,
+g double precision,
+h char(20),
+i varchar(30),
+j text,
+PRIMARY KEY(a, b, c)
+);
+
+CREATE TABLE testing_no_pkey (
+a smallserial,
+b smallint,
+c int,
+d bigint,
+e int,
+f real,
+g double precision,
+h char(20),
+i varchar(30),
+j text
+);
+
+CREATE TABLE testing_unique (
+a smallserial,
+b smallint,
+c int,
+d bigint,
+e int,
+f real,
+g double precision,
+h char(20),
+i varchar(30),
+j text,
+UNIQUE(f, g)
+);
+
+INSERT INTO testing_one_pkey (b, c, d, e, f, g, h, i, j) VALUES (1, 2, 33, 555, 666.777777777, 3.33, 'testval1', 'testval2', 'testval3');
+INSERT INTO testing_multi_pkey (b, c, d, e, f, g, h, i, j) VALUES (1, 2, 33, 555, 666.777777777, 3.33, 'testval1', 'testval2', 'testval3');
+INSERT INTO testing_no_pkey (b, c, d, e, f, g, h, i, j) VALUES (1, 2, 33, 555, 666.777777777, 3.33, 'testval1', 'testval2', 'testval3');
+INSERT INTO testing_unique (b, c, d, e, f, g, h, i, j) VALUES (1, 2, 33, 555, 666.777777777, 3.33, 'testval1', 'testval2', 'testval3');
+
+-- non pkey change
+UPDATE testing_one_pkey SET f = 777.888888888 WHERE b = 1;
+
+-- pkey change
+UPDATE testing_one_pkey SET a = 14 WHERE b = 1;  
+
+-- non pkey change
+UPDATE testing_multi_pkey SET f = 777.888888888 WHERE b = 1;
+
+-- some pkeys change
+UPDATE testing_multi_pkey SET a = 14, c = 14 WHERE b = 1; 
+
+-- all pkeys change
+UPDATE testing_multi_pkey SET a = 15, b = 15, c = 15 WHERE b = 1; 
+
+-- no pkey
+UPDATE testing_no_pkey SET h = 'changed' WHERE b = 1;
+
+-- non unique change
+UPDATE testing_unique SET h = 'changed' WHERE b = 1;
+
+-- one unique val change
+UPDATE testing_unique SET f = 888.888888888 WHERE b = 1;
+
+-- all unique vals change
+UPDATE testing_unique SET f = 888.888888888, g = 6.66 WHERE b = 1;
+
+-- get changes
+SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'regress', 'true', 'skip_empty_xacts', 'true');
+
+DROP TABLE testing_unique;
+DROP TABLE testing_no_pkey;
+DROP TABLE testing_multi_pkey;
+DROP TABLE testing_one_pkey;
+
+SELECT 'end' FROM pg_drop_replication_slot('regression_slot');
diff --git a/contrib/wal2mongo/sql/specval.sql b/contrib/wal2mongo/sql/specval.sql
new file mode 100644
index 0000000000..3781a8da6d
--- /dev/null
+++ b/contrib/wal2mongo/sql/specval.sql
@@ -0,0 +1,27 @@
+\set VERBOSITY terse
+
+-- predictability
+SET synchronous_commit = on;
+
+SELECT 'init' FROM pg_create_logical_replication_slot('regression_slot', 'wal2mongo');
+
+CREATE TABLE testing (
+	a serial PRIMARY KEY,
+	b varchar(80),
+	c bool,
+	d real
+);
+
+BEGIN;
+INSERT INTO testing (b, c, d) VALUES( E'valid: '' " \\ / \d \f \r \t \u447F \u967F invalid: \\g \\k end', FALSE, 123.456);
+INSERT INTO testing (b, c, d) VALUES('aaa', 't', '+inf');
+INSERT INTO testing (b, c, d) VALUES('aaa', 'f', 'nan');
+INSERT INTO testing (b, c, d) VALUES('null', NULL, '-inf');
+COMMIT;
+
+-- get changes
+SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'regress', 'true', 'skip_empty_xacts', 'true');
+
+DROP TABLE testing;
+
+SELECT 'end' FROM pg_drop_replication_slot('regression_slot');
diff --git a/contrib/wal2mongo/sql/string.sql b/contrib/wal2mongo/sql/string.sql
new file mode 100644
index 0000000000..5000716be4
--- /dev/null
+++ b/contrib/wal2mongo/sql/string.sql
@@ -0,0 +1,65 @@
+\set VERBOSITY terse
+
+-- predictability
+SET synchronous_commit = on;
+
+SELECT 'init' FROM pg_create_logical_replication_slot('regression_slot', 'wal2mongo');
+
+-- network address
+CREATE TABLE tbl_net (id serial PRIMARY KEY, a inet, b cidr, c macaddr, d macaddr8);
+
+-- ipv4 in different format
+INSERT INTO tbl_net(a,b,c,d) VALUES('192.168.100.128/25'::inet, '192.168.100.128/25'::cidr, '08:00:2b:01:02:03'::macaddr, '08:00:2b:01:02:03:04:05'::macaddr8);
+INSERT INTO tbl_net(a,b,c,d) VALUES('192.168.0.1/24'::inet, '192.168/24'::cidr, '08-00-2b-01-02-03'::macaddr, '08-00-2b-01-02-03-04-05'::macaddr8);
+INSERT INTO tbl_net(a,b,c,d) VALUES('192.168.0.0/16'::inet, '192.168'::cidr, '08002b:010203'::macaddr, '08002b:0102030405'::macaddr8);
+INSERT INTO tbl_net(a,b,c,d) VALUES('10.0.0.1/8'::inet, '10'::cidr, '08002b-010203'::macaddr, '08002b-0102030405'::macaddr8);
+INSERT INTO tbl_net(a,b,c,d) VALUES('10.1.2.3/32'::inet, '10.1.2.3/32'::cidr, '0800.2b01.0203'::macaddr, '0800.2b01.0203.0405'::macaddr8);
+INSERT INTO tbl_net(a,b,c,d) VALUES('2001:4f8:3:ba::/64'::inet, '2001:4f8:3:ba::/64'::cidr, '0800-2b01-0203'::macaddr, '0800-2b01-0203-0405'::macaddr8);
+
+-- ipv6 and mac in lower case
+INSERT INTO tbl_net(a,b,c,d) VALUES('2001:4f8:3:ba:2e0:81ff:fe22:d1f1/128'::inet, '2001:4f8:3:ba:2e0:81ff:fe22:d1f1/128'::cidr, '08002b010203'::macaddr, '08002b01:02030405'::macaddr8);
+-- ipv6 and mac in upper case
+INSERT INTO tbl_net(a,b,c,d) VALUES('2001:4F8:3:BA:2E0:81FF:FE22:D1F1/128'::inet, '2001:4F8:3:BA:2E0:81FF:FE22:D1F1/128'::cidr, '08002B010203'::macaddr, '08002B0102030405'::macaddr8);
+
+UPDATE tbl_net SET a='10.1.2.3/32'::inet, b='10.1.2.3/32'::cidr, c='0800-2b01-0203'::macaddr, d='0800-2b01-0203-0405'::macaddr8 WHERE id=1;
+DELETE FROM tbl_net WHERE id = 1;
+TRUNCATE TABLE tbl_net;
+
+-- peek changes
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'regress', 'true');
+
+-- get changes
+SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'regress', 'true');
+
+-- drop table
+DROP TABLE tbl_net;
+
+
+-- geo data
+CREATE TABLE tbl_geo (id serial PRIMARY KEY, a point, b line, c lseg, d box, e path, f path, g polygon, h circle);
+ALTER TABLE tbl_geo REPLICA IDENTITY FULL;
+
+-- geo different data types
+INSERT INTO tbl_geo(a,b,c,d,e,f,g,h) VALUES('(1,1)'::point, '[(1,1),(2,2)]'::line, '[(3,3), (4,4)]'::lseg, '((1,1),(2,2))'::box, '[(1,1),(2,2),(3,3)]'::path, '((1,1),(2,2),(3,3))'::path, '((1,1),(2,2),(3,3),(4,4))'::polygon, '<(1,1),5>'::circle);
+
+UPDATE tbl_geo SET a='11,11'::point, b='((11,11),(12,12))'::line, c='((13,13), (14,14))'::lseg, d='(11,11),(12,12)'::box, e='(11,11),(12,12),(13,13)'::path, f='(11,11,12,12,13,13)'::path, g='(11,11),(12,12),(13,13),(14,14)'::polygon, h='((11,11),15)'::circle WHERE id=1;
+
+INSERT INTO tbl_geo(a,b,c,d,e,f,g,h) VALUES('(1,1)'::point, '(1,1),(2,2)'::line, '(3,3), (4,4)'::lseg, '1,1,2,2'::box, '1,1,2,2,3,3'::path, '1,1,2,2,3,3'::path, '(1,1,2,2,3,3,4,4)'::polygon, '1,1,5'::circle);
+
+UPDATE tbl_geo SET a='21,21'::point, b='21,21,22,22'::line, c='23,23, 24,24'::lseg, d='21,21,22,22'::box, e='(21,21,22,22,23,23)'::path, f='21,21,22,22,23,23'::path, g='21,21,22,22,23,23,24,24'::polygon, h='21,21,25'::circle WHERE id=2;
+
+DELETE FROM tbl_geo WHERE id = 1;
+DELETE FROM tbl_geo WHERE id = 2;
+TRUNCATE TABLE tbl_geo;
+
+-- peek changes 
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'regress', 'true');
+
+-- get changes
+SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'regress', 'true');
+
+-- drop table
+DROP TABLE tbl_geo;
+
+
+SELECT 'end' FROM pg_drop_replication_slot('regression_slot');
diff --git a/contrib/wal2mongo/sql/timestamptz.sql b/contrib/wal2mongo/sql/timestamptz.sql
new file mode 100644
index 0000000000..e2523333aa
--- /dev/null
+++ b/contrib/wal2mongo/sql/timestamptz.sql
@@ -0,0 +1,24 @@
+\set VERBOSITY terse
+
+-- predictability
+SET synchronous_commit = on;
+
+SELECT 'init' FROM pg_create_logical_replication_slot('regression_slot', 'wal2mongo');
+
+-- timestamptz
+CREATE TABLE tbl_tstz ( id serial PRIMARY KEY, tstz TIMESTAMPTZ NOT NULL );
+INSERT INTO tbl_tstz (tstz) VALUES('2020-03-24 16:00:30-07') ;
+UPDATE tbl_tstz SET tstz = '2020-03-24 16:30:00-07' WHERE id=1;
+DELETE FROM tbl_tstz WHERE id = 1;
+TRUNCATE TABLE tbl_tstz;
+
+-- peek changes according to action configuration
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'regress', 'true');
+
+-- get changes according to action configuration
+SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'regress', 'true');
+
+
+-- drop tables
+DROP TABLE tbl_tstz;
+SELECT 'end' FROM pg_drop_replication_slot('regression_slot');
diff --git a/contrib/wal2mongo/sql/transaction.sql b/contrib/wal2mongo/sql/transaction.sql
new file mode 100644
index 0000000000..9104bd8765
--- /dev/null
+++ b/contrib/wal2mongo/sql/transaction.sql
@@ -0,0 +1,36 @@
+\set VERBOSITY terse
+
+-- predictability
+SET synchronous_commit = on;
+
+SELECT 'init' FROM pg_create_logical_replication_slot('regression_slot', 'wal2mongo');
+
+-- actions
+CREATE TABLE testing (a varchar(30) primary key);
+INSERT INTO testing (a) VALUES('cary');
+INSERT INTO testing (a) VALUES('john');
+INSERT INTO testing (a) VALUES('peter');
+
+-- define a transaction containing sub transactions
+BEGIN;
+INSERT INTO testing (a) VALUES('david');
+SAVEPOINT p1;
+INSERT INTO testing (a) VALUES('grant');
+SAVEPOINT p2;
+INSERT INTO testing (a) VALUES('mike');
+SAVEPOINT p3;
+INSERT INTO testing (a) VALUES('allen');
+SAVEPOINT p4;
+INSERT INTO testing (a) VALUES('dan');
+ROLLBACK TO SAVEPOINT p3;
+RELEASE SAVEPOINT p1;
+INSERT INTO testing (a) VALUES('cheese');
+COMMIT;
+
+
+-- peek and get changes with and without transaction mode
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'use_transaction', 'true', 'regress', 'true');
+SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'use_transaction', 'false', 'regress', 'true', 'skip_empty_xacts', 'false');
+
+DROP TABLE testing;
+SELECT 'end' FROM pg_drop_replication_slot('regression_slot');
diff --git a/contrib/wal2mongo/sql/xml.sql b/contrib/wal2mongo/sql/xml.sql
new file mode 100644
index 0000000000..968ae5ae29
--- /dev/null
+++ b/contrib/wal2mongo/sql/xml.sql
@@ -0,0 +1,98 @@
+\set VERBOSITY terse
+
+-- predictability
+SET synchronous_commit = on;
+
+SELECT 'init' FROM pg_create_logical_replication_slot('regression_slot', 'wal2mongo');
+
+-- xml data
+CREATE TABLE tbl_xml (id serial primary key, a xml);
+
+-- insert data simple SQL way
+INSERT INTO tbl_xml(a) VALUES('<foo> xml-data </foo>'::xml);
+-- using XMLPARSE and DOCUMENT syntaxes
+INSERT INTO tbl_xml(a) VALUES(XMLPARSE (DOCUMENT'<foo> xml-data </foo>'));
+-- xpath example simple SQL way
+INSERT INTO tbl_xml(a) VALUES('
+<dept
+    xmlns:smpl="http://example.com" smpl:did="DPT011-IT">
+    <name>IT</name>
+    <persons>
+        <person smpl:pid="111">
+            <name>John Smith</name>
+            <age>24</age>
+        </person>
+        <person smpl:pid="112">
+            <name>Michael Black</name>
+            <age>28</age>
+        </person>
+    </persons>
+</dept>'::xml);
+-- xpath example in minify way
+INSERT INTO tbl_xml(a) VALUES('<dept xmlns:smpl="http://example.com" smpl:did="DPT011-IT"><name>IT</name><persons><person smpl:pid="111"><name>John Smith</name><age>24</age></person><person smpl:pid="112"><name>Michael Black</name><age>28</age></person></persons></dept>'::xml);
+-- xpath example using XMLPARSE and DOCUMENT
+INSERT INTO tbl_xml(a) VALUES(XMLPARSE (DOCUMENT'
+<dept
+    xmlns:smpl="http://example.com" smpl:did="DPT011-IT">
+    <name>IT</name>
+    <persons>
+        <person smpl:pid="111">
+            <name>John Smith</name>
+            <age>24</age>
+        </person>
+        <person smpl:pid="112">
+            <name>Michael Black</name>
+            <age>28</age>
+        </person>
+    </persons>
+</dept>'));
+
+-- update using simple SQL way
+UPDATE tbl_xml SET a = '                                                      
+<dept                                                                           
+    xmlns:smpl="http://example.com" smpl:did="DPT011-IT">                       
+    <name>IT</name>                                                             
+    <persons>                                                                   
+        <person smpl:pid="111">                                                 
+            <name>John Smith</name>                                             
+            <age>24</age>                                                       
+        </person>                                                               
+        <person smpl:pid="112">                                                 
+            <name>Michael Black</name>                                          
+            <age>28</age>                                                       
+        </person>                                                               
+    </persons>                                                                  
+</dept>'::xml WHERE id=1;
+
+-- update using XMLPARSE and DOCUMENT syntaxes
+UPDATE tbl_xml SET a = 
+XMLPARSE (DOCUMENT'                               
+<dept                                                                           
+    xmlns:smpl="http://example.com" smpl:did="DPT011-IT">                       
+    <name>IT</name>                                                             
+    <persons>                                                                   
+        <person smpl:pid="111">                                                 
+            <name>John Smith</name>                                             
+            <age>24</age>                                                       
+        </person>                                                               
+        <person smpl:pid="112">                                                 
+            <name>Michael Black</name>                                          
+            <age>28</age>                                                       
+        </person>                                                               
+    </persons>                                                                  
+</dept>') WHERE id=2;
+
+-- delete
+DELETE FROM tbl_xml WHERE id = 1;
+TRUNCATE TABLE tbl_xml;
+
+-- peek changes 
+SELECT data FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'regress', 'true');
+
+-- get changes
+SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'regress', 'true');
+
+-- drop table
+DROP TABLE tbl_xml;
+
+SELECT 'end' FROM pg_drop_replication_slot('regression_slot');
diff --git a/contrib/wal2mongo/wal2mongo.c b/contrib/wal2mongo/wal2mongo.c
new file mode 100644
index 0000000000..398bf178c7
--- /dev/null
+++ b/contrib/wal2mongo/wal2mongo.c
@@ -0,0 +1,972 @@
+/*-------------------------------------------------------------------------
+ *
+ * wal2mongo.c
+ *		logical decoding output plugin for MongoDB
+ *
+ * Copyright (c) 2019-2020, Highgo Global Development Center
+ *
+ * IDENTIFICATION
+ * 		when build under PostgreSQL source code tree,
+ *			contrib/wal2mongo/wal2mongo.c
+ *
+ *-------------------------------------------------------------------------
+ */
+#include "postgres.h"
+
+#include "catalog/pg_type.h"
+
+#include "replication/logical.h"
+#include "replication/origin.h"
+#include "commands/dbcommands.h"
+#include "utils/builtins.h"
+#include "utils/lsyscache.h"
+#include "utils/memutils.h"
+#include "utils/rel.h"
+#include "utils/guc.h"
+#include "common/jsonapi.h"
+#include "utils/datetime.h"
+#include "utils/json.h"
+#include "miscadmin.h"
+
+PG_MODULE_MAGIC;
+
+/* These must be available to pg_dlsym() */
+extern void _PG_init(void);
+extern void _PG_output_plugin_init(OutputPluginCallbacks *cb);
+
+typedef struct
+{
+	bool 		insert;
+	bool		update;
+	bool		delete;
+	bool		truncate;
+} Wal2MongoAction;
+
+typedef struct
+{
+	MemoryContext context;
+	bool		skip_empty_xacts;
+	bool		xact_wrote_changes;
+	bool		only_local;
+	bool 		use_transaction;
+	bool		include_cluster_name;
+	bool		regress;
+	Wal2MongoAction	actions;
+} Wal2MongoData;
+
+static void pg_w2m_decode_startup(LogicalDecodingContext *ctx,
+								  OutputPluginOptions *opt,
+							  	  bool is_init);
+
+static void pg_w2m_decode_shutdown(LogicalDecodingContext *ctx);
+
+static void pg_w2m_decode_begin_txn(LogicalDecodingContext *ctx,
+									ReorderBufferTXN *txn);
+
+static void pg_w2m_decode_begin(LogicalDecodingContext *ctx,
+								Wal2MongoData *data,
+								ReorderBufferTXN *txn);
+
+static void pg_w2m_decode_commit_txn(LogicalDecodingContext *ctx,
+								 	 ReorderBufferTXN *txn, XLogRecPtr commit_lsn);
+
+static void pg_w2m_decode_change(LogicalDecodingContext *ctx,
+							 	 ReorderBufferTXN *txn, Relation rel,
+								 ReorderBufferChange *change);
+
+static void pg_w2m_decode_truncate(LogicalDecodingContext *ctx,
+							   	   ReorderBufferTXN *txn,
+								   int nrelations, Relation relations[],
+								   ReorderBufferChange *change);
+
+static bool pg_w2m_decode_filter(LogicalDecodingContext *ctx,
+							 	 RepOriginId origin_id);
+
+static void pg_w2m_decode_message(LogicalDecodingContext *ctx,
+							  	  ReorderBufferTXN *txn, XLogRecPtr message_lsn,
+								  bool transactional, const char *prefix,
+								  Size sz, const char *message);
+
+static bool split_string_to_list(char *rawstring, char separator, List **sl);
+
+
+/* Will be called immediately after loaded */
+void
+_PG_init(void)
+{
+
+}
+
+/* Initialize callback functions */
+void
+_PG_output_plugin_init(OutputPluginCallbacks *cb)
+{
+	AssertVariableIsOfType(&_PG_output_plugin_init, LogicalOutputPluginInit);
+
+	cb->startup_cb = pg_w2m_decode_startup;
+	cb->begin_cb = pg_w2m_decode_begin_txn;
+	cb->change_cb = pg_w2m_decode_change;
+	cb->truncate_cb = pg_w2m_decode_truncate;
+	cb->commit_cb = pg_w2m_decode_commit_txn;
+	cb->filter_by_origin_cb = pg_w2m_decode_filter;
+	cb->shutdown_cb = pg_w2m_decode_shutdown;
+	cb->message_cb = pg_w2m_decode_message;
+}
+
+
+/* Initialize this plugin's resources */
+static void
+pg_w2m_decode_startup(LogicalDecodingContext *ctx, OutputPluginOptions *opt,
+				  	  bool is_init)
+{
+	ListCell   *option;
+	Wal2MongoData *data;
+
+	data = palloc0(sizeof(Wal2MongoData));
+	data->context = AllocSetContextCreate(ctx->context,
+										  "wal2mongo context",
+										  ALLOCSET_DEFAULT_SIZES);
+	data->skip_empty_xacts = false;
+	data->only_local = false;
+	data->use_transaction = false;
+	data->include_cluster_name = true;
+	data->regress = false;
+
+	data->actions.delete = true;
+	data->actions.insert = true;
+	data->actions.update = true;
+	data->actions.truncate = true;
+
+	ctx->output_plugin_private = data;
+
+	opt->output_type = OUTPUT_PLUGIN_TEXTUAL_OUTPUT;
+	opt->receive_rewrites = false;
+
+	foreach(option, ctx->output_plugin_options)
+	{
+		DefElem *elem = lfirst(option);
+		Assert(elem->arg == NULL || IsA(elem->arg, String));
+		if (strcmp(elem->defname, "skip_empty_xacts") == 0)
+		{
+			/* if option value is NULL then assume that value is false */
+			if (elem->arg == NULL)
+				data->skip_empty_xacts = false;
+			else if (!parse_bool(strVal(elem->arg), &data->skip_empty_xacts))
+				ereport(ERROR,
+						(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
+						 errmsg("could not parse value \"%s\" for parameter \"%s\"",
+							 strVal(elem->arg), elem->defname)));
+		}
+		else if (strcmp(elem->defname, "only_local") == 0)
+		{
+			/* if option value is NULL then assume that value is false */
+			if (elem->arg == NULL)
+				data->only_local = false;
+			else if (!parse_bool(strVal(elem->arg), &data->only_local))
+				ereport(ERROR,
+						(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
+						 errmsg("could not parse value \"%s\" for parameter \"%s\"",
+							 strVal(elem->arg), elem->defname)));
+		}
+		else if (strcmp(elem->defname, "use_transaction") == 0)
+		{
+			/* if option value is NULL then assume that value is false */
+			if (elem->arg == NULL)
+				data->use_transaction = false;
+			else if (!parse_bool(strVal(elem->arg), &data->use_transaction))
+				ereport(ERROR,
+						(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
+						 errmsg("could not parse value \"%s\" for parameter \"%s\"",
+							 strVal(elem->arg), elem->defname)));
+		}
+		else if (strcmp(elem->defname, "force_binary") == 0)
+		{
+			bool		force_binary;
+
+			if (elem->arg == NULL)
+				continue;
+			else if (!parse_bool(strVal(elem->arg), &force_binary))
+				ereport(ERROR,
+						(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
+						 errmsg("could not parse value \"%s\" for parameter \"%s\"",
+								strVal(elem->arg), elem->defname)));
+
+			if (force_binary)
+				opt->output_type = OUTPUT_PLUGIN_BINARY_OUTPUT;
+		}
+		else if (strcmp(elem->defname, "include_cluster_name") == 0)
+		{
+			/* if option value is NULL then assume that value is false */
+			if (elem->arg == NULL)
+				data->include_cluster_name = false;
+			else if (!parse_bool(strVal(elem->arg), &data->include_cluster_name))
+				ereport(ERROR,
+						(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
+						 errmsg("could not parse value \"%s\" for parameter \"%s\"",
+							 strVal(elem->arg), elem->defname)));
+		}
+		else if (strcmp(elem->defname, "regress") == 0)
+		{
+			/* if option value is NULL then assume that value is false */
+			if (elem->arg == NULL)
+				data->regress = false;
+			else if (!parse_bool(strVal(elem->arg), &data->regress))
+				ereport(ERROR,
+						(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
+						 errmsg("could not parse value \"%s\" for parameter \"%s\"",
+							 strVal(elem->arg), elem->defname)));
+		}
+		else if (strcmp(elem->defname, "actions") == 0)
+		{
+			char	*rawstr;
+
+			if (elem->arg == NULL)
+			{
+				elog(DEBUG1, "actions argument is null");
+				/* argument null means default; nothing to do here */
+			}
+			else
+			{
+				List		*selected_actions = NIL;
+				ListCell	*lc;
+
+				rawstr = pstrdup(strVal(elem->arg));
+				if (!split_string_to_list(rawstr, ',', &selected_actions))
+				{
+					pfree(rawstr);
+					ereport(ERROR,
+							(errcode(ERRCODE_INVALID_NAME),
+							 errmsg("could not parse value \"%s\" for parameter \"%s\"",
+								 strVal(elem->arg), elem->defname)));
+				}
+
+				data->actions.insert = false;
+				data->actions.update = false;
+				data->actions.delete = false;
+				data->actions.truncate = false;
+
+				foreach(lc, selected_actions)
+				{
+					char *p = lfirst(lc);
+
+					if (strcmp(p, "insert") == 0)
+						data->actions.insert = true;
+					else if (strcmp(p, "update") == 0)
+						data->actions.update = true;
+					else if (strcmp(p, "delete") == 0)
+						data->actions.delete = true;
+					else if (strcmp(p, "truncate") == 0)
+						data->actions.truncate = true;
+					else
+						ereport(ERROR,
+								(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
+								 errmsg("could not parse value \"%s\" for parameter \"%s\"",
+									 p, elem->defname)));
+				}
+
+				pfree(rawstr);
+				list_free_deep(selected_actions);
+			}
+		}
+		else
+		{
+			ereport(ERROR,
+					(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
+					 errmsg("option \"%s\" = \"%s\" is unknown",
+							elem->defname,
+							elem->arg ? strVal(elem->arg) : "(null)")));
+		}
+	}
+}
+
+/* Cleanup this plugin's resources */
+static void
+pg_w2m_decode_shutdown(LogicalDecodingContext *ctx)
+{
+	Wal2MongoData *data = ctx->output_plugin_private;
+
+	/* cleanup our own resources via memory context reset */
+	MemoryContextDelete(data->context);
+}
+
+/* BEGIN callback */
+static void
+pg_w2m_decode_begin_txn(LogicalDecodingContext *ctx, ReorderBufferTXN *txn)
+{
+	Wal2MongoData *data = ctx->output_plugin_private;
+
+	data->xact_wrote_changes = false;
+	if (data->skip_empty_xacts)
+		return;
+
+	pg_w2m_decode_begin(ctx, data, txn);
+}
+
+static void pg_w2m_decode_begin(LogicalDecodingContext *ctx,
+								Wal2MongoData *data,
+								ReorderBufferTXN *txn)
+{
+
+	/* Skip this callback if transaction mode is not enabled */
+	if(!data->use_transaction)
+		return;
+
+	/* first write the session variable for Mongo */
+	OutputPluginPrepareWrite(ctx, false);
+	appendStringInfo(ctx->out, "session%u%s = db.getMongo().startSession();",
+			data->regress == true? 0 : txn->xid, ctx->slot->data.name.data);
+	OutputPluginWrite(ctx, false);
+
+	/* then write transaction start */
+	OutputPluginPrepareWrite(ctx, true);
+	appendStringInfo(ctx->out, "session%u%s.startTransaction();",
+			data->regress == true? 0 : txn->xid, ctx->slot->data.name.data);
+	OutputPluginWrite(ctx, true);
+}
+
+/* COMMIT callback */
+static void
+pg_w2m_decode_commit_txn(LogicalDecodingContext *ctx, ReorderBufferTXN *txn,
+					 	 XLogRecPtr commit_lsn)
+{
+	Wal2MongoData *data = ctx->output_plugin_private;
+
+	/* Skip this callback if it is an empty transaction */
+	if (data->skip_empty_xacts && !data->xact_wrote_changes)
+		return;
+
+	/* Skip this callback if transaction mode is not enabled */
+	if(!data->use_transaction)
+		return;
+
+	/* first write the commit transaction cmd */
+	OutputPluginPrepareWrite(ctx, false);
+	appendStringInfo(ctx->out, "session%u%s.commitTransaction();",
+			data->regress == true? 0 : txn->xid, ctx->slot->data.name.data);
+	OutputPluginWrite(ctx, false);
+
+	/* then write session termination */
+	OutputPluginPrepareWrite(ctx, true);
+	appendStringInfo(ctx->out, "session%u%s.endSession();",
+			data->regress == true? 0 : txn->xid, ctx->slot->data.name.data);
+	OutputPluginWrite(ctx, true);
+}
+
+/* Generic message callback */
+static bool
+pg_w2m_decode_filter(LogicalDecodingContext *ctx,
+				 	 RepOriginId origin_id)
+{
+	Wal2MongoData *data = ctx->output_plugin_private;
+
+	if (data->only_local && origin_id != InvalidRepOriginId)
+		return true;
+	return false;
+}
+
+/* Postgres data types to MongoDB data types conversion
+ * if input data has already been quoted, then use false to skip quotation
+ * if input data hasn't been quoted yet, then use true to request a quotation
+ */
+static void
+print_w2m_data_type(StringInfo s, char *outputstr, const char *type, bool quotation)
+{
+	const char *valptr;
+
+	for (valptr = outputstr; *valptr; valptr++)
+	{
+		char ch = *valptr;
+		if(ch == '{')
+		{
+			appendStringInfo(s, "[%s(", type);
+			if (quotation)
+				appendStringInfo(s, "\"");
+		}
+		else if(ch == ',')
+		{
+			if (quotation)
+				appendStringInfo(s, "\"");
+			appendStringInfo(s, "),%s(", type);
+			if (quotation)
+				appendStringInfo(s, "\"");
+		}
+		else if(ch == '}')
+		{
+			if (quotation)
+				appendStringInfo(s, "\"");
+			appendStringInfo(s, ")]");
+		}
+		else
+			appendStringInfoChar(s, ch);
+	}
+}
+
+/* PG to MG data conversion */
+static void
+print_w2m_literal(StringInfo s, Oid typid, char *outputstr)
+{
+	const char *valptr;
+
+	switch (typid)
+	{
+		case INT2OID:
+		case INT4OID:
+			appendStringInfo(s, " NumberInt(\"%s\")", outputstr);
+			break;
+
+		case FLOAT4OID:
+			appendStringInfoString(s, outputstr);
+			break;
+
+		case INT8OID:
+		case OIDOID:
+			appendStringInfo(s, " NumberLong(\"%s\")", outputstr);
+			break;
+
+		case FLOAT8OID:
+		case NUMERICOID:
+			appendStringInfo(s, " NumberDecimal(\"%s\")", outputstr);
+			break;
+
+		case BITOID:
+		case VARBITOID:
+			appendStringInfo(s, "B'%s'", outputstr);
+			break;
+
+		case BOOLOID:
+			if (strcmp(outputstr, "t") == 0)
+				appendStringInfoString(s, "true");
+			else
+				appendStringInfoString(s, "false");
+			break;
+
+		case TIMESTAMPTZOID:
+			appendStringInfo(s, " ISODate(\"%s\")", outputstr);
+			break;
+
+		case UUIDOID:
+			appendStringInfo(s, " UUID(\"%s\")", outputstr);
+			break;
+
+		case BYTEAOID:
+			appendStringInfo(s, " HexData(0, \"");
+			for (valptr = outputstr+2; *valptr; valptr++)
+			{
+				char		ch = *valptr;
+				appendStringInfoChar(s, ch);
+			}
+			appendStringInfo(s, "\")");
+			break;
+
+		/* Array data type */
+		case BOOLARRAYOID:
+			for (valptr = outputstr; *valptr; valptr++)
+			{
+				char ch = *valptr;
+				if(ch == '{')
+					appendStringInfoChar(s, '[');
+				else if(ch == ',')
+					appendStringInfoChar(s, ',');
+				else if(ch == '}')
+					appendStringInfoChar(s, ']');
+				else
+				{
+					if (ch == 't')
+						appendStringInfoString(s, "true");
+					else
+						appendStringInfoString(s, "false");
+				}
+			}
+			break;
+
+		case INT2ARRAYOID:
+		case INT4ARRAYOID:
+			print_w2m_data_type(s, outputstr, "NumberInt", false);
+			break;
+
+		case FLOAT4ARRAYOID:
+            for (valptr = outputstr; *valptr; valptr++)
+            {
+                char ch = *valptr;
+                if(ch == '{')
+                    appendStringInfoChar(s, '[');
+                else if(ch == ',')
+                    appendStringInfoChar(s, ',');
+                else if(ch == '}')
+                    appendStringInfoChar(s, ']');
+                else
+                {
+                    if (SQL_STR_DOUBLE(ch, false))
+                        appendStringInfoChar(s, ch);
+                    appendStringInfoChar(s, ch);
+                }
+            }
+			break;
+
+		case INT8ARRAYOID:
+			print_w2m_data_type(s, outputstr, "NumberLong", false);
+			break;
+
+		case TIMESTAMPTZARRAYOID:
+			print_w2m_data_type(s, outputstr, "ISODate", false);
+			break;
+
+		case FLOAT8ARRAYOID:
+		case NUMERICARRAYOID:
+			print_w2m_data_type(s, outputstr, "NumberDecimal", true);
+			break;
+
+		case UUIDARRAYOID:
+			print_w2m_data_type(s, outputstr, "UUID", true);
+			break;
+
+		case CHARARRAYOID:
+		case NAMEARRAYOID:
+		case TEXTARRAYOID:
+		case BPCHARARRAYOID:
+		case VARCHARARRAYOID:
+			for (valptr = outputstr; *valptr; valptr++)
+			{
+				char ch = *valptr;
+				if(ch == '{')
+					if(*(valptr+1) == '{' || *(valptr+1) == '"')
+						appendStringInfoChar(s, '[');
+					else
+						appendStringInfo(s, "[\"");
+				else if(ch == ',')
+					if(*(valptr+1) == '{' || *(valptr+1) == '"')
+						appendStringInfoChar(s, ',');
+					else
+						appendStringInfo(s, "\",\"");
+				else if(ch == '}')
+					if(*(valptr-1) != '}' && *(valptr-1) != '"')
+						appendStringInfo(s, "\"]");
+					else
+						appendStringInfoChar(s, ']');
+				else
+				{
+					if (SQL_STR_DOUBLE(ch, false))
+						appendStringInfoChar(s, ch);
+					appendStringInfoChar(s, ch);
+				}
+			}
+			break;
+		/* Array data type */
+		case JSONOID:
+		case JSONBOID:
+			appendStringInfo(s, "%s", outputstr);
+			break;
+		case JSONPATHOID:
+			appendStringInfoChar(s, '\"');
+			for (valptr = outputstr; *valptr; valptr++)
+			{
+				char ch = *valptr;
+
+				if(ch != '"')
+					appendStringInfoChar(s, ch);
+			}
+			appendStringInfoChar(s, '\"');
+			break;
+		case JSONARRAYOID:
+		case JSONBARRAYOID:
+			/* For JSON arrays, we need to strip first and last curly brackets and
+			 * replace them with square brackets in order to be accepted by Mongodb
+			 */
+			outputstr = outputstr + 1;
+			outputstr[strlen(outputstr) - 1] = '\0';
+			appendStringInfoChar(s, '[');
+			for (valptr = outputstr; *valptr; valptr++)
+			{
+				char ch = *valptr;
+				if(ch == '\\' && (valptr+1) != NULL && *(valptr+1) == '"' )
+				{
+					/* replace all \" with " */
+					appendStringInfoChar(s, '"');
+				}
+				else if(ch == '"')
+				{
+					/* ignore all the double quote without backslash escape */
+				}
+				else
+				{
+					appendStringInfoChar(s, ch);
+				}
+			}
+			appendStringInfoChar(s, ']');
+			break;
+
+		case XMLOID:
+			appendStringInfoChar(s, '\"');
+			for (valptr = outputstr; *valptr; valptr++)
+			{
+				char ch = *valptr;
+
+				if (ch == '\n')
+						continue;
+				if ((ch == '"') && (*(valptr+1) != '\0'))
+					appendStringInfoChar(s, '\\');
+
+				if (SQL_STR_DOUBLE(ch, false))
+					appendStringInfoChar(s, ch);
+				appendStringInfoChar(s, ch);
+			}
+			appendStringInfoChar(s, '\"');
+			break;
+
+		default:
+			appendStringInfoChar(s, '\"');
+			for (valptr = outputstr; *valptr; valptr++)
+			{
+				char ch = *valptr;
+
+				if (SQL_STR_DOUBLE(ch, false))
+					appendStringInfoChar(s, ch);
+				appendStringInfoChar(s, ch);
+			}
+			appendStringInfoChar(s, '\"');
+			break;
+	}
+}
+
+/* print the tuple 'tuple' into the StringInfo s */
+static void
+tuple_to_stringinfo(StringInfo s, TupleDesc tupdesc, HeapTuple tuple, bool skip_nulls,
+					Bitmapset * pkAttrs)
+{
+	int			natt;
+
+	appendStringInfoString(s, " \{ ");
+	/* print all columns individually */
+	for (natt = 0; natt < tupdesc->natts; natt++)
+	{
+		Form_pg_attribute attr; /* the attribute itself */
+		Oid			typid;		/* type of current attribute */
+		Oid			typoutput;	/* output function */
+		bool		typisvarlena;
+		Datum		origval;	/* possibly toasted Datum */
+		bool		isnull;		/* column is null? */
+
+		attr = TupleDescAttr(tupdesc, natt);
+
+		/*
+		 * don't print dropped columns, we can't be sure everything is
+		 * available for them
+		 */
+		if (attr->attisdropped)
+			continue;
+
+		/*
+		 * Don't print system columns, oid will already have been printed if
+		 * present.
+		 */
+		if (attr->attnum < 0)
+			continue;
+
+		typid = attr->atttypid;
+
+		/*
+		 * if pkAttrs is valid and not empty. Check if the current attribute is
+		 * a member of the pkAttrs. If not a member, continue to next attribute.
+		 */
+		if(pkAttrs && !bms_is_empty(pkAttrs) &&
+				!bms_is_member(natt + 1 - FirstLowInvalidHeapAttributeNumber,
+							   pkAttrs))
+			continue;
+
+
+		/* get Datum from tuple */
+		origval = heap_getattr(tuple, natt + 1, tupdesc, &isnull);
+
+		if (isnull && skip_nulls)
+			continue;
+
+		/* print attribute name */
+		if ( natt != 0 )
+			appendStringInfoString(s, ", ");
+
+		appendStringInfoString(s, quote_identifier(NameStr(attr->attname)));
+
+		/* print separator */
+		appendStringInfoChar(s, ':');
+
+		/* query output function */
+		getTypeOutputInfo(typid,
+						  &typoutput, &typisvarlena);
+
+		/* print data */
+		if (isnull)
+			appendStringInfoString(s, "null");
+		else if (typisvarlena && VARATT_IS_EXTERNAL_ONDISK(origval))
+			appendStringInfoString(s, "unchanged-toast-datum");
+		else if (!typisvarlena)
+		{
+			if (typid == TIMESTAMPTZOID || typid == TIMESTAMPTZARRAYOID)
+			{
+				char		buf[MAXDATELEN + 1];
+				JsonEncodeDateTime(buf, origval, TIMESTAMPTZOID, NULL);
+				print_w2m_literal(s, typid, buf);
+			}
+			else
+				print_w2m_literal(s, typid,
+						  OidOutputFunctionCall(typoutput, origval));
+		}
+		else
+		{
+			Datum		val;	/* definitely detoasted Datum */
+			char	   *result;
+			char	   *rp;
+
+			val = PointerGetDatum(PG_DETOAST_DATUM(origval));
+			if (typid == BYTEAOID )
+			{
+				/* Print hex format */
+				rp = result = palloc(VARSIZE_ANY_EXHDR(val) * 2 + 2 + 1);
+				*rp++ = '\\';
+				*rp++ = 'x';
+				rp += hex_encode(VARDATA_ANY(val), VARSIZE_ANY_EXHDR(val), rp);
+				*rp = '\0';
+				print_w2m_literal(s, typid, result);
+			}
+			else
+				print_w2m_literal(s, typid, OidOutputFunctionCall(typoutput, val));
+		}
+
+	}
+	appendStringInfoString(s, " }");
+}
+
+/*
+ * callback for individual changed tuples
+ */
+static void
+pg_w2m_decode_change(LogicalDecodingContext *ctx, ReorderBufferTXN *txn,
+				 	 Relation relation, ReorderBufferChange *change)
+{
+	Wal2MongoData *data;
+	Form_pg_class class_form;
+	TupleDesc	tupdesc;
+	MemoryContext old;
+	Bitmapset  *pkAttrs;
+
+	data = ctx->output_plugin_private;
+
+	/* output BEGIN if we haven't yet */
+	if (data->skip_empty_xacts && !data->xact_wrote_changes)
+	{
+		pg_w2m_decode_begin(ctx, data, txn);
+	}
+	data->xact_wrote_changes = true;
+
+	class_form = RelationGetForm(relation);
+	tupdesc = RelationGetDescr(relation);
+
+	/* Avoid leaking memory by using and resetting our own context */
+	old = MemoryContextSwitchTo(data->context);
+
+	/* write the db switch command */
+	OutputPluginPrepareWrite(ctx, false);
+
+	/* Here we are concatenating ClusterName, DatabaseName, and SlotName to form
+	 * a unified database name in MongoDB's perspective, so Mongo knows the changes
+	 * are streamed from which cluster, which database and via which slot
+	 *
+	 * TODO: we will introduce more configurable options to fine-tune this output style
+	 * behaviors.
+	 */
+	if(data->include_cluster_name)
+	{
+		char *cluster_name = GetConfigOptionByName("cluster_name", NULL, true);
+
+		appendStringInfo(ctx->out, "use %s_%s_%s;",
+						data->regress == true ? "mycluster" : (cluster_name[0] == '\0' ? "mycluster" : cluster_name),
+						data->regress == true ? "mydb" : get_database_name(MyDatabaseId),
+						ctx->slot->data.name.data[0] == '\0' ? "myslot" :
+								ctx->slot->data.name.data);
+	}
+	else
+	{
+		appendStringInfo(ctx->out, "use %s_%s;",
+						data->regress == true ? "mydb" : get_database_name(MyDatabaseId),
+						ctx->slot->data.name.data[0] == '\0' ? "myslot" :
+								ctx->slot->data.name.data);
+	}
+	OutputPluginWrite(ctx, false);
+
+	OutputPluginPrepareWrite(ctx, true);
+	appendStringInfoString(ctx->out,
+						   quote_qualified_identifier("db", class_form->relrewrite ?
+													  get_rel_name(class_form->relrewrite) :
+													  NameStr(class_form->relname)));
+
+	switch (change->action)
+	{
+		case REORDER_BUFFER_CHANGE_INSERT:
+			appendStringInfoString(ctx->out, ".insertOne(");
+			if (change->data.tp.newtuple == NULL)
+				appendStringInfoString(ctx->out, " (no-tuple-data)");
+			else
+				tuple_to_stringinfo(ctx->out, tupdesc,
+									&change->data.tp.newtuple->tuple,
+									true, NULL);
+			appendStringInfoString(ctx->out, " );");
+			break;
+		case REORDER_BUFFER_CHANGE_UPDATE:
+			appendStringInfoString(ctx->out, ".updateOne(");
+			if (change->data.tp.oldtuple != NULL)
+			{
+				/*
+				 * the old tuple will contain the old value of primary key if it has been changed under DEFAULT replica identity
+				 * the old tuple will contain all old values regardless if they have bee changed under FULL replica identity
+				 * either way, find the primary key columns and print them only.
+				 */
+				pkAttrs = RelationGetIndexAttrBitmap(relation,
+													 INDEX_ATTR_BITMAP_PRIMARY_KEY);
+				tuple_to_stringinfo(ctx->out, tupdesc,
+									&change->data.tp.oldtuple->tuple,
+									true, pkAttrs);
+				bms_free(pkAttrs);
+			}
+			else
+			{
+				/*
+				 * the old tuple is NULL case. This means primary key has not been changed and the replica identity is not set to FULL.
+				 * we need to figure out the primary key column from new tuple
+				 */
+				if (change->data.tp.newtuple != NULL)
+				{
+					pkAttrs = RelationGetIndexAttrBitmap(relation,
+														 INDEX_ATTR_BITMAP_PRIMARY_KEY);
+					if (!pkAttrs)
+					{
+						/* old tuple is NULL and no primary key is present in newtuple: Write null */
+						appendStringInfoString(ctx->out, "{ selector: \"null\" }");
+					}
+					else
+					{
+						tuple_to_stringinfo(ctx->out, tupdesc,
+											&change->data.tp.newtuple->tuple,
+											true, pkAttrs);
+						bms_free(pkAttrs);
+					}
+				}
+			}
+
+			if (change->data.tp.newtuple != NULL)
+			{
+				appendStringInfoString(ctx->out, ", \{ $set: ");
+				tuple_to_stringinfo(ctx->out, tupdesc,
+									&change->data.tp.newtuple->tuple,
+									false, NULL);
+				appendStringInfoString(ctx->out, " }");
+			}
+			appendStringInfoString(ctx->out, " );");
+			break;
+		case REORDER_BUFFER_CHANGE_DELETE:
+			appendStringInfoString(ctx->out, ".deleteOne(");
+			/* if there was no PK, we only know that a delete happened */
+			if (change->data.tp.oldtuple == NULL)
+				appendStringInfoString(ctx->out, " (no-tuple-data)");
+			/* In DELETE, only the replica identity is present; display that */
+			else
+			{
+				/* For delete, we looked up the primary key attribute bitmap for use
+				 * in the subsequent tuple_to_stringinfo() call so the output will only
+				 * contain primary key columns in the oldtuple instead of all columns.
+				 */
+				pkAttrs = RelationGetIndexAttrBitmap(relation,
+												     INDEX_ATTR_BITMAP_PRIMARY_KEY);
+				tuple_to_stringinfo(ctx->out, tupdesc,
+									&change->data.tp.oldtuple->tuple,
+									true, pkAttrs);
+				bms_free(pkAttrs);
+			}
+			appendStringInfoString(ctx->out, " );");
+			break;
+		default:
+			Assert(false);
+	}
+
+	MemoryContextSwitchTo(old);
+	MemoryContextReset(data->context);
+
+	OutputPluginWrite(ctx, true);
+}
+
+static void
+pg_w2m_decode_truncate(LogicalDecodingContext *ctx, ReorderBufferTXN *txn,
+				   	   int nrelations, Relation relations[], ReorderBufferChange *change)
+{
+	/* TODO: to be supported in future version  */
+	elog(DEBUG1, "TRUNCATE replication is not supported\n");
+}
+
+static void
+pg_w2m_decode_message(LogicalDecodingContext *ctx,
+				  	  ReorderBufferTXN *txn, XLogRecPtr lsn, bool transactional,
+					  const char *prefix, Size sz, const char *message)
+{
+	/* message decoding not supported */
+	elog(DEBUG1, "message decoding is not supported\n");
+}
+
+static bool
+split_string_to_list(char *rawstring, char separator, List **sl)
+{
+	char	   *nextp;
+	bool		done = false;
+
+	nextp = rawstring;
+
+	while (isspace(*nextp))
+		nextp++;				/* skip leading whitespace */
+
+	if (*nextp == '\0')
+		return true;			/* allow empty string */
+
+	/* At the top of the loop, we are at start of a new identifier. */
+	do
+	{
+		char	   *curname;
+		char	   *endp;
+		char	   *pname;
+
+		curname = nextp;
+		while (*nextp && *nextp != separator && !isspace(*nextp))
+		{
+			if (*nextp == '\\')
+				nextp++;	/* ignore next character because of escape */
+			nextp++;
+		}
+		endp = nextp;
+		if (curname == nextp)
+			return false;	/* empty unquoted name not allowed */
+
+		while (isspace(*nextp))
+			nextp++;			/* skip trailing whitespace */
+
+		if (*nextp == separator)
+		{
+			nextp++;
+			while (isspace(*nextp))
+				nextp++;		/* skip leading whitespace for next */
+			/* we expect another name, so done remains false */
+		}
+		else if (*nextp == '\0')
+			done = true;
+		else
+			return false;		/* invalid syntax */
+
+		/* Now safe to overwrite separator with a null */
+		*endp = '\0';
+
+		/*
+		 * Finished isolating current name --- add it to list
+		 */
+		pname = pstrdup(curname);
+		*sl = lappend(*sl, pname);
+
+		/* Loop back if we didn't reach end of string */
+	} while (!done);
+
+	return true;
+}
